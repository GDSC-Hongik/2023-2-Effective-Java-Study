### Item86 : Serializable을 구현할지는 신중히 결정하라

###### Serializable
어떤 클래스가 직렬화/역직렬화가 가능하도록 하려면 단순히 Serializable 인터페이스를 구현하면 된다.  
굉장히 간단해 보이지만 내재하는 문제는 꽤나 심각하다

###### Serializable을 구현하면 릴리스한 뒤에 수정하기가 어렵다
클래스가 Serializable을 구현하면 그 직렬화된 바이트 스트림 형태도 마치 공개 api처럼 외부에 공개된다.
그렇기 때문에 한 번 공개된 직렬화 형태는 지속적으로 지원을 해줘야 한다는 뜻이다.  
커스텀한 직렬화 형태를 사용하는 것이 아닌 자바에서 제공하는 기본 직렬화 형태를 사용한다면
처음 Serializable을 적용한 시점의 클래스 구조로 직렬화 형태가 묶이게 된다.

그 이후에 혹시나 클래스 내부 구조를 수정할 일이 생긴다면   
구버전 인스턴스 형태의 직렬화 -> 신버전 인스턴스 형태로의 역직렬화를 시도하게 되므로 문제가 발생하게 된다. 

###### Serializable을 구현하면 버그와 보안 구멍이 생길 위험이 있다
객체 생성의 기본 매커니즘은 '생성자'를 사용하여 생성하는 것이다.  
그런데 직렬화/역직렬화는 겉으로 드러나지 않는 객체 생성 매커니즘인 것이다. 겉으로 드러나지도 않으면서
생성자의 원칙인 '불변식을 모두 지키며 객체 생성 시에는 외부로부터의 접근을 막아야 한다'라는 조건을 만족하기란 쉽지가 않다.

###### Serializable을 구현하면 해당 클래스의 신버전 릴리즈 시 테스트할 내용이 늘어난다
Serializable을 구현한 클래스 내부를 수정한 뒤 릴리즈하기 전에는 
- 신버전 인스턴스 직렬화 -> 구버전 인스턴스로 역직렬화
- 구버전 인스턴스 직렬화 -> 신버전 인스턴스로 역직렬화

가 모두 가능한지 테스트를 한 뒤에야 릴리즈를 할 수 있다. 만약 처음 설계 시 커스텀 직렬화 형태를 구축했다면
이 작업은 그나마 수월할 것이다.

###### 상속용으로 설계한 클래스는 대부분 Serializable을 구현하면 안되며 인터페이스 Serializable을 상속하면 안된다
이는 해당 클래스를 확장하는 하위 클래스에게 많은 부담을 위임하므로 지양하는 것이 좋다.

###### 그럼에도 Serializable을 구현 or Serializable을 구현한 클래스를 사용한다면 주의해야 할 점
- 본인이 작성하는 클래스의 필드가 직렬화가 가능하면서 확장도 가능한데 불변식을 지켜야 하는 경우
  - 해당 클래스 내부에 final 키워드를 붙인 finalize 메서드를 추가하여 하위 클래스에서 finalize 메서드를 재정의하지 못하도록 하자.
  그렇지 않으면 finalizer 공격에 취약해진다.
- 본인이 작성하는 클래스의 필드가 기본값으로(정수형은 0, boolean은 false, 참조형은 null) 초기화되면 불변식이 깨지는 경우
  - 클래스 내부에 
    ```java
    private void readObjectNoDate() throws InvalidObjectException {
        throw new InvalidObjectException();
    }
    ```
    메서드를 반드시 추가하자.

