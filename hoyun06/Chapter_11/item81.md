### Item81 : wait, notify 보다는 동시성 유틸리티를 애용하라

자바 5에 고수준 동시성 유틸리티가 도입되면서 wait, notify 의 중요도는 많이 떨어졌다.  
wait, notify 는 정확하게 사용하기 쉽지가 않으므로 저자는 동시성 유틸리티 사용을 권장한다.

###### 고수준 동시성 유틸리티
고수준 동시성 유틸리티는 크게 세 범주로 나눌 수 있다
- 실행자 프레임워크
- 동시성 컬렉션
- 동기화 장치

이번 item에선 동시성 컬렉션과 동기화 장치에 대해 알아보려고 한다.

###### 동시성 컬렉션
동시성 컬렉션은 기존의 'List', 'Queue', 'Map'과 같은 컬렉션에 '동시성'요소를 첨가한 고수준 컬렉션이다.  
'동시성'을 달성하기 위해 각 컬렉션 내부에서 '동기화'를 진행하므로 해당 컬렉션들이 제공하는 '동시성'은 필연적으로 준수되며
클라이언트에서 명시적으로 `락`을 사용하면 오히려 더 성능이 나빠진다.  
동시성 컬렉션의 등장으로 기존의 컬렉션 중에 '동시성'기능을 제공하던 것들(ex. Collections.synchronizedMap)의 활용도가 많이 떨어졌다.  
그 대안으로 'ConcurrentHashMap' 과 같은 동시성 컬렉션을 사용하면 된다.

###### 동기화 장치
동기화 장치는 스레드 간의 작업 조율을 가능하게 한다. 동기화 장치의 종류에는 CountDownLatch, Semaphore, CyclicBarrier, Exchanger 등이 있는데
여기선 CountDownLatch 를 살펴보려고 한다.

CountDownLatch는 일회성 방벽으로서 특정 스레드(들)의 작업이 끝날 때까지 다른 스레드(들)를 대기하게 하는 역할이다.

CountDownLatch 메서드의 유일한 생성자는 매개변수로 int 를 받는데 이 int는 해당 CountDownLatch 객체의 countDown 메서드가 몇 번 호출되어야 대기 중인 
스레드를 깨울 것인지를 나타낸다.

###### wait, notify 를 사용해야 하는 경우
레거시 코드를 다루는 경우 wait, notify 를 사용해야 하는 경우가 발생한다.  
wait 메서드는 스레드가 어떤 조건이 충족되기를 기다리게 하는 메서드다. wait 메서드를 사용하는 표준 관용구가 있는데 다음과 같다.
```java
synchronized (object) {
    while(<condition not satisfied>) {
        object.wait();
    }
    ..
}
```
wait 메서드는 반드시 반복문 내부에서 호출되어야 한다. 조건이 충족되지 않았음에도 notifyAll 메서드를 통해 해당 스레드가 깨어날 수도 있기 때문이다.   
그 경우 비정상적인 프로그램 실행을 막기 위한 수단이 위 반복문이다. 위 while 문은 wait 메서드 호출 전후로 조건이 충족되었는지를 검사하기 때문에 혹시나 notifyAll 을 통해 스레드가 깨어나도
조건 검사를 해서 아직 조건이 충족되지 않았다면 wait를 호출해 다시 대기 상태로 돌아가도록 조치한다.

notify 메서드는 대기 중인 스레드 중 한 개만 깨우는 것이고 notifyAll 메서드는 대기 중인 모든 스레드를 깨우는 것이다.  
nofityAll의 경우 모든 스레드를 깨우긴 하지만 이 경우에는 깨어난 모든 스레드가 `락`을 얻기 위해 경쟁해야 하는 race condition에 돌입한다.

저자는 거의 대부분의 경우에 notify 대신 notifyAll을 호출하는 것이 바람직하다고 했다.
notifyAll 은 깨어나야 하는 스레드들이 모두 깨어남을 보장하므로 프로그램이 정상적으로 동작하기 때문이다.

## 핵심 정리
    자바의 고수준 동시성 유틸리티가 있다면 굳이 wait, notify 를 사용할 이유가 없다.
    단 레거시 코드에서 wait, notify 를 사용한다면 wait은 조건 검사를 수행하는 반복문 내부에서만 호출하고
    웬만해선 notifyAll을 통해 대기 중인 스레드들을 깨우자