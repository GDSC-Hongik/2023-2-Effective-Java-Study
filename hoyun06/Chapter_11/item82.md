### Item82 : 스레드 안전성 수준을 문서화하라

api 제공자는 여러 스레드가 동일 메서드를 실행했을 때의 동작을 명확히 문서화해야 한다.  
이를 좀 더 구체화해서 말하면 해당 클래스의 스레드 안전성 수준을 명확히 문서화해야 한다.

###### 스레드 안전성을 나타내는 정도
스레드 안전성 수준이 높은 순서대로 설명하고자 한다.
- 불변(immutable)
  - 이 클래스는 사실상 상수와 같아서 외부 동기화가 필요없는 클래스다. ex) String, Long, BigInteger
- 무조건적 스레드 안전(unconditionally thread safe)
  - 이 클래스의 객체는 변경될 수 있으나 클래스 내부에서 충실히 동기화를 했기 때문에 추가적인 외부 동기화는 필요없는 클래스다
  ex) CocurrentHashMap, AtomicLong
- 조건부 스레드 안전(conditionally thread safe)
  - 기본적으론 무조건적 스레드 안전과 동일하나 일부 메서드의 경우 동시에 호출하려면 외부 동기화가 필요한 클래스다.
  ex) Collections.synchronizedMap (해당 객체의 Iterator의 경우 외부 동기화가 필요하다)
- 스레드 안전하지 않음(not thread safe)
  - 이 클래스의 객체는 수정될 수 있으며 동시에 사용하기 위해선 각각의 메서드 호출을 클라이언트가 선택한 외부 동기화 메커니즘으로 감싸야 한다
  ex) ArrayList, HashMap
- 스레드 적대적(thread hostile)
  - 이 클래스는 모든 메서드 호출을 외부 동기화 메커니즘으로 감싸도 스레드 안전하지 않다. 대부분의 스레드 적대적인 클래스는 static 데이터를
  동기화 없이 수정한다.

특히, 조건부 스레드 안전한 클래스를 문서화할 땐 주의해야 한다.  
메서드들을 어떤 순서로 호출할 경우 외부 동기화가 필요하고 그때 얻어야 하는 `락`을 얻어야 하는지도 명시해야 한다.

###### 클래스가 외부에서 사용할 수 있는 락을 제공
클래스단에서 클라이언트가 외부에서 사용할 수 있는 공개 `락`을 제공하면 이를 사용하는 클라이언트 측에서는
일련의 메서드 호출을 원자적으로 수행할 수 있다.  
하지만 이 공개 `락`과 클래스 내부에서 사용하는 고수준 동시성 제어 메커니즘은 함께 사용할 수 없다는 단점이 있고
악의적인 클라이언트가 이 공개 `락`을 잡고 오랫동안 놔주지 않는 서비스 거부 공격(denial of service attack)에 취약하다.

이 문제를 해결하려면 비공개 락 객체를 이용하면 된다.
```java
private final Object lock = new Object();

public void func() {
    synchronized (lock) {
        ...
    }
}
```
이렇게 하면 lock 객체는 외부에 공개되지 않으므로 외부로부터의 동기화 관여를 차단할 수 있다.  
단, 위 방식은 무조건적 스레드 안전 클래스에서만 사용할 수 있다. 조건부 스레드 안전 클래스는 특정 호출 순서에 필요한 `락`이 무엇인지
외부에 알려줘야 하기 때문이다.

## 핵심 정리
    각 클래스의 스레드 안전성 수준을 정확히 문서화하자.
    조건부 스레드 안전 클래스의 경우 특정 순서로 메서드 호출 시 필요한 락에 대한 정보도 같이 제공하자.