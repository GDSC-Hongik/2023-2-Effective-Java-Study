### Item28 : 배열보다는 리스트를 사용하라

###### 배열과 제네릭 타입의 차이점
배열
- 배열은 공변성을 가진다. 즉, 타입의 상하관계에 따라 배열 간에 캐스팅이 가능하다.
- 배열은 실체화된다. 즉, 컴파일 타임뿐만 아니라 런타임에도 해당 배열에 들어가는 원소의 타입을 검사한다.

제네릭 타입
- 제네릭 타입은 불공변이다. 즉, `List<Object> objects;` 변수로 `new List<String>()`을 가리킬 수 없다.
- 제네릭 타입은 실체화되지 않는다. 제네릭 타입은 `타입 소거` 방식으로 동작하므로 런타임에는 타입 매개변수가 사라진다.

이러한 차이점때문에 배열같은 경우 
- 제네릭 타입 배열 (ex. `new List<E>[]`)
- 매개변수화 타입 배열 (ex. `new List<String>[]`)
- 타입 매개변수 배열 (ex. `new E[]`)

을 허용하지 않는다. **타입 안전성이 확보되지 않기 때문이다.**  
제네릭 타입을 사용했던 이유는 컴파일 타임에 타입 안전성을 확인하여
런타임에 ClassCastException을 발생시키지 않도록 하기 위함이었다.   
하지만 제네릭 배열을 허용하면 타입 안전성이 깨지고 그렇게 되면 제네릭 타입의 장점이 무용지물이 되는 상황이 발생한다는 것이다.

* 위에서 언급한 `List<E>, List<String>, E` 는 **실체화 불가 타입이다**.
즉, 제네릭의 소거 메커니즘에 의해 런타임에는 컴파일 타임보다 타입 정보를 적게 가진다는 의미이다.
제네릭 코드 중 실체화 가능한 것은 비한정적 와일드카드밖에 없다.

제네릭 컬렉션의 경우, 해당 컬렉션의 정규 타입 매개변수 원소를 담는 배열을 반환하는 것이 완전 불가능하지 않지만 
제네릭 배열 생성 오류 혹은 비검사 형변환 경고등 거슬리는 점들이 많다. 이런 경우 해당 타입의 배열을 반환하기 보다는 해당 타입 원소를 넣을 수 있는
리스트(제네릭 컬렉션)로 반환하자.

## 핵심 정리
    배열은 컴파일 타임에 타입 안전하고, 제네릭은 런타임에 타입 안전하다. 
    2개가 모두 사용되는 경우에 컴파일 오류나 경고가 발생한다면 배열을 리스트로 변경해보자.
