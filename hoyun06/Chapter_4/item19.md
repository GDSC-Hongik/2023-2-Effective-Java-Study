### Item19 : 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

#### 상속할 때 지켜야 할 제약 
###### 메서드를 재정의하면 어떤 일이 일어나는지를 정확히 기술한 문서를 작성해야 한다.
- 조금 더 자세히 말하자면 재정의 가능한 메서드가 해당 슈퍼 클래스 내부적으로 어떻게 사용되는지를 기술한 문서가 필요하다.
- 클래스의 api로 공개된 메서드가 해당 클래스 내부에 있는 다른 메서드를 호출할 수 있는데 이때 호출하는 메서드가
재정의 가능한 메서드라면 이에 대해 명시해야 한다.
- 하지만 이를 위해 내부 구현을 명시해야 하므로 캡슐화가 어느 정도 깨지는 것은 불가피한 것으로 보인다.

###### 상속 시 서브 클래스가 필요로 할 기능들을 적절히 추려 protected 멤버로 제공해야 한다.
이 말이 해당 서브 클래스의 최종 사용자를 위한 protected 메서드를 제공하란 뜻은 아니니 오해하면 안된다.

아쉽게도 '적절히 추린다'라는 작업은 직접 테스트를 하는 것밖엔 답이 없다. 여기서 직접 테스트한다는 것은 실제로 
**서브 클래스를 생성하여 상속을 진행해 보는 것**을 의미한다. 실제로 상속을 하면서 필요한 것들을 protected 멤버로 추가하면 된다.  
저자는 약 3개 정도의 서브 클래스를 생성하여 테스트하는 것이 좋다고 언급했다.

하지만 널리 쓰일 상속용 클래스를 설계할 때는 우리가 선언하는 protected 멤버가 공개 api로 공개되기 때문에 
지속적인 관리의 대상이 됨을 인식해야 한다.

###### 상속용 클래스의 생성자는 직/간접적으로 재정의 가능 메서드를 호출해선 안된다.
이 규칙을 어기면 프로그램이 오동작한다.  
상속의 경우 슈퍼 클래스의 생성자가 서브 클래스의 생성자보다 먼저 실행된다. 그렇기 때문에 슈퍼 클래스의 생성자 내부에서 재정의 가능 메서드를 호출하면
객체 초기화 작업이 제대로 진행되지 않을 여지가 생긴다.
```java
public class Super {
    public Super() {
        overrideMe();
    }
    
    public void overrideMe() { }
}
```
```java
public class Sub extends Super {
    private final Instant instant;
    
    Sub() {
        instant = Instant.now();
    }
    
    @Override
    public void overrideMe() {
        System.out.println(instant);
    }
    
    public static void main(String[] args) {
        Sub sub = new Sub();
        sub.overrideMe();
    }
}
```
Super의 생성자에서는 overrideMe 메서드를 호출하는데 이 메서드는 Sub에서 재정의됐다. 그래서 첫 번째
sout 문에서는 null이 출력되고 main에서 출력하는 sout 문에서만 제대로 된 instant 값이 출력된다.
> private, static, final 키워드가 붙은 메서드는 안심하고 호출해도 된다. 재정의가 불가능하기 때문이다.    

이 문제는 생성자 뿐만이 아니라 clone, readObject 메서드에도 동일하게 적용된다.  
따라서, clone 과 readObject 메서드에서도 재정의 가능 메서드를 호출해선 안된다.  
- readObject: 하위 클래스 객체까지의 역직렬화가 마무리되기 전에 재정의 메서드가 실행된다.
- clone: 하위 클래스 객체까지의 완전한 복사가 되기 전에 재정의 메서드가 실행된다.  
결국 제대로 초기화된 객체가 생성되기 전에 재정의 메서드가 실행되면서 우리의 의도와는 다른 객체가 생성될 수 있다.

###### 상속을 고려하지 않고 설계한 클래스에서 상속을 막는 방법
이 내용은 사실 이전 item에서도 다뤘던 내용들이다.
1. 해당 클래스를 final로 선언한다.
2. 모든 생성자를 private 혹은 package-private으로 선언하고 public 정적 팩터리를 제공한다.
    - 생성자가 private이므로 상속을 하더라도 인스턴스를 생성할 수 없을 것이다.

###### 상속을 고려하지 않고 설계했지만 꼭 상속을 해야겠다면..
- 해당 클래스 내부에서는 재정의 가능 메서드를 호출하지 않도록 설계하고 이를 문서화하여 사용자들에게 알려준다.
    - 슈퍼 클래스 내부에선 재정의 가능 메서드를 호출하지 않으니 서브 클래스에서 메서드를 재정의 하더라도 실행에 문제가 없다.
- 만약, 슈퍼 클래스 내부에서 재정의 가능 메서드를 호출하고 있다면 수정할 수 있는 방법이 있다.
  1. 재정의 가능 메서드 코드를 private 메서드로 추출한다.
  2. 내부적으로 재정의 가능 메서드를 호출하는 부분을 1번에서 추출한 private 메서드로 모두 갈아끼운다.

## 핵심 정리
    상속을 고려한 클래스를 설계하는 것은 마냥 쉽지만은 않다. 재정의 가능 메서드가 어떻게 사용되는지 내부 구현을 
    문서화하여 밝혀야 하고 때때로 protected 멤버를 제공해야 하는 경우도 있다. 그래서 정말 상속이 꼭 필요한 경우가 아니라면
    컴포지션 혹은 래퍼 클래스 패턴을 이용하는 것이 좋다.