### Item61 : 박싱된 기본 타입보다는 기본 타입을 사용하라

###### 기본 타입과 박싱된 기본 타입의 차이점
- 기본 타입은 값만 가지고 있지만 박싱된 기본 타입은 값  + identity(레퍼런스 값)을 가지고 있다
  - 그래서 박싱된 기본 타입은 같은 값을 가지더라도 서로 다른 객체라고 판별할 수 있다
- 기본 타입의 값은 언제나 유효하나 박싱된 기본 타입은 null을 가질 수 있다
- 기본 타입이 박싱된 기본 타입에 비해 시간적, 메모리적으로 우수하다

```java
Comparator<Integer> naturalOrder = 
    (i1, i2) -> (i1 < i2) ? -1 : (i1 == i2 ? 0 : 1);
```
위 코드는 정상적으로 동작하는 것처럼 보이지만 그렇지 않다. i1, i2 가 같은 값을 가지더라도 i1, i2가 각각 서로 다른 
Integer 객체를 가리킨다면 i1 == i2 에서 항상 false가 나와 1을 반환하게 되는 문제가 발생한다.  
즉, 박싱된 기본 타입의 값을 비교할 때는 '=='을 사용하면 안된다는 것이다. 위 코드를 의도한대로 수정하려면 Integer 타입의 i1, i2를
int 타입으로 변환한 뒤에 값 비교를 해야 한다.

###### 박싱된 기본 타입을 써야 하는 경우
- 컬렉션의 키 혹은 값으로 기본 타입을 쓰고 싶은 경우
  - 컬렉션같은 경우 타입 매개변수로 기본 타입을 허용하지 않으므로 이 경우엔 무조건 박싱된 기본 타입을 사용해야 한다
- 일반화하면 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수를 사용할 때는 무조건 박싱된 기본 타입을 사용해야 한다
- 리플렉션을 사용하여 메서드를 호출하는 경우에도 반드시 박싱된 기본 타입을 사용해야 한다

### 어댑터(래퍼) 패턴
우리가 흔히 아는 그 어댑터를 생각하면 된다.  
프로그래밍에서의 `어댑터 패턴`은 서로 호환되지 않는 구조를 가지고 있는 클래스들을 `어댑터 클래스`라는 연결 클래스를 이용하여 
함께 동작할 수 있도록 하는 패턴이다.
> 즉, 어댑터란 이미 구축되어 있는 것을 새로운 어떤것에 사용할때 양 쪽 간의 호환성을 유지해 주기 위해 사용하는 것으로서, 기존 시스템에서 새로운 업체에서 제공하는 기능을 사용하려고 할때 서로 간의 인터페이스를 어댑터로 일치시켜줌으로써 호환성 및 신규 기능 확장을 할수 있다고 보면 된다
출처: https://inpa.tistory.com/entry/GOF-💠-어댑터Adaptor-패턴-제대로-배워보자 [Inpa Dev 👨‍💻:티스토리]

**어댑터(래퍼) 패턴 적용 가능한 예시**
- 기존 코드에 새로운 외부 라이브러리를 적용하려고 할 때 발생하는 구조적 차이를 어댑터 패턴으로 처리할 수 있음
- 새로운 인터페이스를 정의하고 사용하려고 할 때 기존에 작성되어 있던 레거시 코드를 재사용하는 과정에서 존재하는 구조적 차이를 어댑터 패턴으로 처리할 수 있음 

> 이후로는 기존 코드에 새로운 외부 라이브러리를 적용하는 경우를 가정하고 설명을 하려고 한다

###### 객체 어댑터
- `컴포지션`을 이용하여 어댑터 패턴을 구현
- 어댑터 클래스 내부에 컴포지션을 이용하여 외부 라이브러리 혹은 레거시 인터페이스를 참조하고 실제 로직 실행을 해당 참조 객체에게 위임하는 방식
![](https://refactoring.guru/images/patterns/diagrams/adapter/structure-object-adapter.png?id=33dffbe3aece294162440c7ddd3d5d4f)  
**출처: https://refactoring.guru/ko/design-patterns/adapter**