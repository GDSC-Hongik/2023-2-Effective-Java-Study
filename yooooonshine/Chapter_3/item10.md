# equals는 일반 규약을 지켜 재정의하라
---
기본적인 Object의 equals 메서드는 다음과 같다.
![[Pasted image 20231219155458.png]]
즉 두 객체의 참조가 같으면 같다고 판단한다.

기본적으로 모든 클래스는 Object를 상속하며, 때때로 equals를 재정의하여 사용하게 된다.
하지만 equals를 제대로 재정의하는 것은 생각보다 쉽지 않으며, 잘 못 정의하면 끔직한 결과를 초래할 가능성이 높다.

따라서 재정의할 필요가 없다면 아예 재정의를 하지 않는 것이 좋다.



## 어떨때 재정의를 하지 말아야 할까?
### 1. 각 인스턴스가 본질적으로 고유하다.
즉 값을 표현하는 게 아니라, 동작하는 개체를 표현하는 클래스의 경우 두 객체는 본질적으로 다르다고 판단하므로, 참조값으로 equals를 판단해도 무관하다.

반대로 값을 표현하는 경우
```java
String a = "a";
String b = "a";
```
String의 기본적인 성질로 같은 "a"객체 주소를 갖게 되므로 a와 b는 동일하지만, 값이므로 equals를 재정의해주는 것이 좋다.
즉 만원 화폐의 경우 그 종이보다는 만원이라는 가치가 중요해서 식별id가 달라도 같은 만원으로 보는 상황에서 재정의 하는 것이다.
### 2. 인스턴스의 '논리적 동치성'을 검사할 일이 없다.
두 객체의 논리적 동치성을 검사하는 경우, equals를 재정의해야겠지만
만약 필요하지 않다고 판단하면 굳이 재정의할 필요 없다.
### 3. 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
Set 구현체는 AbstractSet이 구현한 equals를 상속받아 쓴다.
이처럼 그냥 상속받아 써도 충분한 경우 굳이 equals를 재정의할 필요없다.
### 4. 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.
즉 private클래스의 경우 객체가 생성될 일이 없으므로 굳이 equals 메서드를 재정의할 필요 없다.
### 5. 싱글톤이나, enum(이것 또한 싱글톤)은 객체가 하나이므로 굳이 equals메서드를 재정의 할 필요 없다.



## 그럼 어떨때 재정의해야할까?

### 1. 두 객체의 논리적 동등성을 확인해야 하는 데 상위 클래스에서 이를 재정의하지 않았을 때
즉 값 클래스처럼 프로그래머가 두 값이 같은 지를 통해 객체가 같은 지 판단하려 한다면 재정의한다.

## equals 메서드를 재정의할 때 따라야하는 규약
1. 반사성: null이 아닌 x에 대해 x.equals(x)는 true이다.
2. 대칭성: null이 아닌 모든 x,y에 대해 x.equals(y)가 true이면 y.equals(x)도 true
3. 추이성: null이 아닌 x,y,z에 대해 x.equals(y)가 true이고, y.equals(z)도 true라면 x.equals(z)도 true이어야 한다.
4. 일관성 null이 아닌 x,y에  대해 x.equals(y)를 반복해서 호출하면 항상  true이거나 항상 false를 반환해야 한다.
5. null아님: null이 아닌 x에 대해 x.equals(null)은 false이어야 한다.

이를 따라야 하는 이유는 이 객체를 사용하는 컬렉션 클래스를 포함한 모든 클래스는 객체가 equals 규약을 지킨다고 가정하고 동작하기 때문이다.