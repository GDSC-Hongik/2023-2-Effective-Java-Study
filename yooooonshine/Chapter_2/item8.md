# finalizer와 cleaner 사용을 피해라
---
자바에는 생성자(constructor)의 반대 개념인 소멸자가 존재한다.
즉 생성자는 객체를 생성할 때 호출되는 메서드이며 
반대로 소멸자는 객체가 소멸될 때 호출되는 메서드이다.

자바의 소멸자로는 finalizer와 cleaner  두 가지가  존재한다.

결론부터 말하면 finalizer는 언제 실행될 지 예측할 수 없고,느리고 정확하게 동작한다는 보장을 할 수가 없어 사용하면 안된다.
따라서 이에 대한 대안으로 java9에 cleaner가 추가되었다.
하지만 여전히 cleaner또한 예측하기 어려운 것은 여전하다.

## c++의 파괴자와 java의 소멸자는 다르다.
c++, c에서 파괴자는 생성자와 반대 개념으로 객체를 소멸시킬 때 보편적으로 사용하는 기능이다.
java에서 접근할 수 없게 된 객체를 소멸시키는 방법으로 일반적으로 가비지컬렉터가 자동으로 처리한다.

참고로 여기서 비메모리 자원이란 데이터베이스 연결, 네트워크 연결, 파일등을 의미하며, 이러한 자원들은 명시적으로 해제해야 한다.

# finalizer와 cleaner를 사용하면 안되는 이유
## 1.finalizer와 cleaner는 언제 실행될 지 알 수 없다.
finalizer와 cleaner의 호출되는 시기는 정확히 정해져 있지 않으며, 가비지 컬렉터 알고리즘에 달려 있어, 시스템이 finalizer와 cleaner 호출을 게을리한다면 아주 늦게 호출될 수도 있다.
이렇게 시기를 알 수 없다면 오류를 일으킬 수 있다.
예를 들어 시스템이 동시에 열 수 있는 파일의 개수는 정해져 있는 데, 시스템이 finalizer 호출을 게을리하여 파일을 열기만 하여, 더 이상 새롭게 파일을 열 수 없는 상황이 올 수있기 때문이다.

따라서 언제는 잘 동작했다가, 언제는 잘 동작하지 않는 검출하기 어려운 에러를 내포하게 된다.

또한 우리는 finalizer가 호출될 시기를 임의로 정할 수 없기 때문에, 이에 대한 유일한 해결책은 finalizer를 사용하지 않는 것이다.
## 2.finalizer와 cleaner는 수행 여부조차 보장하지 못한다.
접근할 수 없는 일부 객체에 딸린 종료 작업을 전혀 수행하지 못한 채 프로그램이 중단될 수 있다는 얘기이다.
프로그램 생애주기와 상관없는 상태를 영구적으로 수정하는 작업에서는 절대 finalizer나 cleaner에 의존해서는 안된다.

즉 `finalize()`메서드가 호출되기 전에 프로그램 자체가 종료되어, 수행이 아예 안될 수 도 있다. 따라서 `finalize()`를 통해 상태를 영구적으로 수정하는 작업을 한다면 절대 `finalize()` 에 의존하면 안된다
## 3.finalizer 동작 중 발생한 예외는 무시된다.
finalizer 동작 중 발생한 예외는 무시되며, 처리할 작업이 남았더라도 그 순간 종료된다.  
이렇게 예외가 터지면 그 즉시 중단되기에 객체는 마무리가 덜 된 상태로 남아 있게 되며, 이러한 객체를 다른 스레드가 접근하려 한다면 어떤 일이 일어날 지 예측할 수 없게 된다.
일반적인 보통의 경우에는 예외가 터지면, 그 즉시 스레드를 중단시키고 스택 추적 내역을 출력한다. 하지만 finalizer는 출력조차 하지 않는다.

그나마 cleaner는 자신의 스레드는 통제하므로 이런 문제는 발생하지 않는다.
## 4.finalizer와 cleaner는 심각한 성능 문제도 동반한다.
`AutoCloseable`객체를 생성하고 가비지 컬렉터가 수거하는 시간보다,
`finalizer`를 사용하면 50배나 더 많은 시간이 걸린다.

`finalizer`와 `cleaner`를 클라이언트가 자원을 반납하지 않았을 경우에 대비한 안전망 형태로만 사용한다면 `AutoCloseable`에 비해 5배의 시간만 들이면 해결할 수 있다.
## 5.finalizer를 사용한 클래스는 fianlizer 공격에 노출되어 심각한 보안 문제를 일으킬 수도 있다.
예를 들어  A라는 클래스를 B라는 클래스가 상속받았고, `fianlize()`를 Override했다고 하자.
B라는 클래스의 생성자에서 예외가 터지면, 객체가 죽으며`finalize()`가 호출된다.
이 `finalize()`에 악의적으로 B의 정적 필드에 객체 참조값을 저장해버리면, 객체에 대한 참조가 존재하므로 가비지 컬렉터는 이를 수거하지 못한다.

즉 A라는 클래스를 공격자가 상속받아 B라는 클래스로 악의적인 행동을 하는 것이다.

이를 예방하기 위해
* 클래스를 final 클래스로 만들어 누구도 이를 상속받을 수 없게 하자. 
* 만약 final 클래스가 아닌 클래스를 방어하려면 `finalize()` 메서드를 만들고 final로 선언하여 악용할 수 없게 하자.


# 그럼 finalizer와 cleaner 대신 어떻게 해야할까?
이건 try-with-source와 `AutoCloseable`을 구현하여 인스턴스를 다 쓰면 `close()`를 호출하게 한다.

이와 더불어서 각 인스턴스는 자신이 닫혔는 지를 추적하는 것이 좋다.
즉 close메서드에서 자신 객체가 더 이상 유효하지 않다는 정보를 특정 필드에 저장해두고 다른 메서드가 이 필드를 확인하여, 객체가 닫힌 후에 객체를 호출하였다면 에러를 발생시키는 것이다.

# 그럼 finalizer와 cleaner는 어떨때 사용해야 할까
이에 대해 두가지가 존재한다.
1. 소유자가 close메서드를 호출하지 않는 것에 대한 안전망 역할을 한다.
2. 네이티브 피어와 연관된 객체에서 사용한다.
여기서 네이티브 피어란 무엇일까?

## 네이티브 피어
java 언어에서 네이티브 코드(c, c++등의 코드)와 상호작용하는 기술을 가리킨다.

네이티브 메서드: 다른 언어로 된 코드를 호출하는 메서드를 의미한다.

즉 java 객체가 네이티브 메서드를 통해 다른 언어로 된 코드를 호출하고, 이를 실행한 결과를 java 객체에 반환하는 데,  이러한 기능을 갖는 객체를 네이티브 피어라고 한다.

이러한 네이티브 객체는 자바 객체가 아니므로 가바지 컬렉터가 인지하지 못하므로, finalizer나 cleaner가 적절하게 나서서 처리해야한다.
다만 즉시 자원을 회수해야 한다면 `close`메서드를 사용해야 한다.