# 클래스와 멤버의 접근 권한을 최소화하라
---

## 어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 차이
어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 차이는 바로 클래스 내부 데이터와 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐이다.

즉 잘 설계된 컴포넌트는 구현과 API를 깔끔하게 분리되어 외부 컴포넌트와 오직 API를 통해서만 소통하며 서로의 내부 동작 방법에는 개의치 않는다.
(이 개념은 정보 은닉, 캡슐화를 의미한다.)

## 정보 은닉의 장점은 무엇일까
* 시스템 개발 속도를 높인다. 여러 컴포넌트를 병렬로 개발할 수 있기 때문이다.
* 시스템 관리 비용을 낮춘다. 각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 부담도 적기 때문이다.
* 정보 은닉 자체가 성능을 높여주지는 않지만, 성능 최적화에 도움을 준다. 완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한 다음 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화할 수 있기 때문이다.
* 소프트웨어 재사용성을 높인다. 외부에 거의 의존하지 않고 독자적으로 동작할 수 있는 컴포넌트라면 그 컴포넌트와 함께 개발되지 않은 낯선 환경에서도 유용하게 쓰일 가능성이 크기 때문이다.
* 큰 시스템을 제작하는 난이도를 낮춰준다. 시스템 전체가 아직 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할수 있기 때문이다.
## 그럼 정보은닉은 어떻게 할까
그것은 바로 접근 제한자(private. protected, public)을 클래스, 인터페이스, 맴버에 명시하여 정보은닉을 처리할 수 있다.
또한 소프트웨어가 올바로 동작하는 한 가장 낮은 접근 수준을 부여해야 한다. 즉 클래스와 맴버의 접근성을 가능한 좁혀야 한다.

## 톱레벨 클래스와 인터페이스의 접근 수준
이는 public과 package-private가 존재한다.

package-private는 인터페이스나 클래스를 패키지 밖에서 사용할 수 없고, 내부적으로만 사용가능하므로, 불필요해지면 언제든 수정, 삭제할 수 있다.

반면 public은 공개 API로 패키지 밖에서도 사용가능하므로,다른 곳에서 쓰일 수 있으므로, 하위 호환을 위해 영원히 관리해야만 한다.

따라서 public인 클래스가 그 패키지 내부에서만 사용한다면, package-private로 바꿔주자.

참고로 한 클래스에서만 사용하는 package-private 톱레벨 클래스나 인터페이스는 그 클래스 안에 private static으로 중첩시키면, 이 클래스에서만 접근가능하게 할 수 있다.
단순 package-private이면 패키지내 다른 클래스가 사용할 수 있기 때문이다.

## 맴버에 부여할 수 있는 접근 수준
* private: 맴버를 선언한 클래스에서만 사용 가능
* package-private: 맴버가 소속된 패키지 내에서 접근 가능, 접근 제한자를 명시하지 않았을 때 적용되는 접근 수준
* protected:package-private이나, 이 맴버를 선언한 클래스의 하위 클래스에서도 접근 가능
* public: 모든 곳에서 접근 가능

웬만한 클래스들은 모두 private로 만들자. 다른 곳에서 필요로 하는 것만 package-private로 풀어주며. 공개 API만 public으로 만든다.

참고로 `Serializable`을 구현한 클래스에서는 그 필드들도 의도치 않게 공개 API가 될 수 있다.
## 그럼 public클래스에서 package-private 맴버를 갖는다면?
이렇게 되면 클래스자체는 패키지 외부에서 볼 수 있지만, package-private맴버는 볼 수 없다.
## 그럼 package-private 클래스에서 publick 맴버를 갖는다면?
이렇게 되면 클래스 자체가 패키지 내부에서만 보이기에, 외부에서는 클래스자체가 안보이므로, 맴버 또한 볼 수 없다.

## 따라서 public 클래스에서 변수가 package-private에서 protected로 바뀐다면?
그럼 맴버가 패키지 외부에서 볼 수 없었지만, protected로 바꾸면 범위가 넓어져서 외부에서 볼 수 있게되며,
그럼 공개 API이므로 유지보수가 필요하며, 영원히 지원되어야 한다.

따라서 protected 맴버의 수는 적을수록 좋다.
## 하위 클래스의 접근범위는 상위클래스보다 좁게 설정할 수 없다.
"상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙(리스코프 치환 원칙)"에 따라, 이를 지키려면, 상위 클래스에서는 하위클래스를 접근할 수 있어야 한다.
따라서 하위 클래스의 접근범위는 상위클래스보다 좁게 설정할 수 없다.

## 테스트를 위해 클래스, 인터페이스, 맴버를 공개API로 만들어서는 안된다.
종종 private메서드를 테스트하기 위해, public으로 바꿀려 할 수 있는데, 이럴 경우 package-private까지는 넓힐 수 있으나, public으로 바꾸면 안된다.
test 코드를 테스트 대상과 같은 패키지에 두면 접근할 수 있기에 package-private로 충분하기 때문이다.
## public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.
필드가 가변 객체를 참조하거나, final 아닌 인스턴스를 public으로 선언 하면, 필드에 담는 값을 제한할 힘을 잃는다.

또한 동시 접근이 가능하기에, 필드가 수정될 때는 다른 작업을 할 수 없으므로, 스레드 안전하지 않다.

## 상수는 예외이다.
기본적으로 static 필드 또한 private로 해야 하나, 
대문자 알파벳과 \_로 변수이름을 표현하는 상수라면
public static final로 필드를 공개해도 된다.
다만 변수는 반드시 불변 객체나 기본 타입 값이어야 한다.

## 배열의 경우는 무조건 조심하자
배열은 final로 잡아도 public이면 외부에서 수정할 수 있으므로,
웬만하면 public으로 두지 말자.
설령 public static final이라 하더라도 배열이므로 변경 가능하기 때문이다.

배열 주소를 알 수만 있다면 변경 가능하기에 애초부터 배열 주소를 return하면 안된다.
해결책은 두가지이다.
1. 배열 자체를 불변리스트로 만드는 것이다.
2. 배열을 private로 만들고, 그 배열의 복사본을 반환하는 방법이다.(방어적 복사)
