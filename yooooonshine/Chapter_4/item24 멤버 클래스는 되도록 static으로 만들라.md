## 중첩 클래스
다른 클래스 안에 정의된 클래스를 의미한다.
중첩 클래스는 자신을 감싼 바깥 클래스에서만 쓰여야 하며, 그 이외의 쓰임이 있다면 톱레벨클래스로 만들어야 한다.

## 중첩 클래스의 종류
* 정적 맴버 클래스
* 비정적 멤버 클래스
* 익명 클래스
* 지역 클래스
## 정적 멤버 클래스란?
* static이 붙는다.
* 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있다.
* 이 외의 부분은 다른 일반 클래스와 똑같다.
* 정적 멤버 클래스는 다른 정적 멤버와 똑같은 접근 규칙을 적용받는다.
* private로 선언하면 바깥 클래스에서만 접근 가능하다.

```java
class A{
    private int a;
  
    static class B{
    	    private int b;  
    }
}
```
생성은?
```java
void foo(){
    A.B b = new B();
}
```
이와 같이 A.B등으로 A생성없이 B를 생성할  수 있다.
따라서 바깥 인스턴스와 독립적으로 존재할 수 있고, 이런 상황에서는 정적 멤버 클래스로 만든다.

## 비정적 멤버 클래스란?
* 정적 멤버 클래스와 다르게 static이 붙지 않는다.
* 비정적 멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결된다.
* 중첩 클래스의 인스턴스가 바깥 인스턴스와 독립적으로 존재할 수 있지 않다면 비정적 멤버클래스로 만든다. 왜냐하면 비정적 멤버 클래스는 바깥 인스턴스없이는 생성할 수 없기 때문이다.
* 바깥 클래스의 인스턴스 메서드에서 비정적 멤버 클래스의 생성자를 호출해 만들 수도 있고, `바깥 인스턴스의 클래스.new Member()`등의 수동 생성도 가능하다.
```java
class A{
    private int a;
  
    class B{
  	      private int b;  
    }
}
```
생성은?
```java
void foo(){
    A a = new A();
    A.B b = a.new B();
}
//or
void foo(){
    A.B b = new A().new B();
}
```
다음과 같이 반드시 A를 생성한 후 B를 생성할 수 있다.

# 멤버 클래스에서 바깥 인스턴스에 접근할 일이 없으면 무조건 static을 붙여서 정적 멤버 클래스로 만들자.
static을 생략하면 바깥 인스턴스로의 숨은 참조가 생기고, 참조를 저장하기 위해 시간과 공간이 소비된다.
바깥 클래스는 더 이상 사용되지 않지만 **내부 클래스의 참조로 인해 GC가 수거하지 못해서 바깥 클래스의 메모리 해제를 하지 못하는 경우가 발생**할 수 있다.




## 익명 클래스란?
이름 없는 클래스, 바깥 클래스의 멤버도 아니며, 쓰이는 시점에 선언과 동시에 인스턴스를 만든다.

이펙티브 자바에서는 익명 클래스에 대해 다음과 같이 설명한다.
`비정적인 문맥에서 사용될 때만 바깥 클래스의 인스턴스를 참조할 수 있다. 정적 문맥에서라도 상수 변수 이외의 정적 멤버는 가질 수 없다.`
이게 뭔말일까
### 정적 문맥
`정적 문맥에서는 프로그램이 실행되기 전에 이미 결정되는 상태입니다.`
즉 정적 멤버 상수와, 정적 메서드는 정적 문맥에 속한다.
즉 static등은 클래스 자체에 속하고 인스턴스에 속하는게 아니므로 this 를 사용할 수 없다.
## 비정적 문맥
`비정적 문맥은 실행 중에 결정되는 상태입니다. 이는 특정 인스턴스에 속하는 상태입니다.`
즉 인스턴스 멤버 변수, 메서드등은 비정적 문맥에 속한다.

자 다시 이해해보자
`비정적인 문맥에서 사용될 때만 바깥 클래스의 인스턴스를 참조할 수 있다. 정적 문맥에서라도 상수 변수 이외의 정적 멤버는 가질 수 없다.`
비정적인 문맥이면 바깥 클래스의 인스턴스를 참조할 수 있다. 예시를 들어보자
```java
public class Calculator {
    private int x;
    private int y;

    public Calculator(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int plus() {
        Operator operator = new Operator() {

            @Override
            public int plus() {
                // Calculator.plus()가 static이면 x, y 참조 불가
                return x + y;
            }
        };
        return operator.plus();
    }
}

interface Operator {
    int plus();
}
```
여기서 plus가 익명클래스 바깥 클래스의 Calculator클래스 인스턴스의 값 x,y를 참조했다. 만약 정적문맥이었으면, 인스턴스가 안 만들어졌을수도 있으니, 참조를 못하게 한다. 따라서 x,y를 참조할 수 없다라는 뜻이다.


### 익명 클래스의 단점
* 선언한 지점에서만 인스턴스를 만들 수 있다.
* 클래스의 이름이 필요한 작업은 할 수 없다.
* 여러 인터페이스를 구현할 수 없고, 인터페이스를 구현하는 동시에 다른 클래스를 상속할 수 없다.

이러한 단점으로 익명 클래스 대신 요즘은 람다식을 사용한다.

# 지역 클래스
---
* 드물게 사용되며, 지역 클래스는 지역 변수를 선언할 수 있는 곳이면 어디서든 선언할 수 있고, 유효범위도 지역변수와 같다.
* 멤버 클래스처럼 이름이 있고, 반복해서 사용가능하다.
* 비정적 문맥에서 사용될 때만 바깥 인스턴스를 참조할 수 있고, 정적 멤버는 가질 수 없다.

지역 클래스는 어떻게 생긴것일까?
코드를  통해 보자
```java
public class A {
	public String number = "123";
	
    public void foo() {
        // 지역변수처럼 선언
        class LocalClass {
            private String name;
            // private static int staticNumber; // 정적 멤버 가질 수 없음

            public LocalClass(String name) {
                this.name = name;
            }
		 public void print() {
                System.out.println(number + name);
            }
            
		}
	}
}

```
보다시피 메서드 안에 클래스가 정의된 것을 볼 수 있다.
이름이 있으니 반복사용가능하다.
또한 당연히 정적문맥일 경우 컴파일시 생성되므로, 바깥 인스턴스는 참조 불가능하며, 마찬가지로 런타임 때 지역 클래스가 읽히므로 정적 멤버는 있을 수 없다.