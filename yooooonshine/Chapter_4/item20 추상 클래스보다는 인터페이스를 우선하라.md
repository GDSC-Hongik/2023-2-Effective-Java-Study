# 추상 클래스보다는 인터페이스를 우선하라
---
우선적으로 추상 클래스와 인터페이스가 뭐가 다른 지 알아보자.

일단 추상 클래스는 다중 상속(한 클래스가 한 번에 두 개 이상의 클래스를 상속받는 것)이 불가능하며, 단일 상속만 가능하다. 반면 인터페이스는 인터페이스끼리 다중 상속(즉 한 인터페이스가 여러 인터페이스를 상속 받음), 다중 구현(클래스에 여러 인터페이스 받아서 구현) 이 가능하다.

## 인터페이스 특징
* 인터페이스는 좌표의 덧셈, 그냥 덧셈등, 덧셈이라는 같은 동작을 한다는 것을 보장할 때 만들어 사용한다.
* 내부의 모든 메서드는 `public abstract`로 정의한다.
* 예외적으로 `static`, `private`, `default`를 붙이면, 구체적인 메서드를 가질 수 있다.
* 내부의 필드는 `public static final`이어야 한다. `int a = 5;`등으로 별도로 지정하지 않아도, 자동으로 `public static final`로 처리된다.
## 추상 클래스 특징
* 추상 클래스는 다중 상속이 안되며, 오직 단일 상속만 허락한다.
* 추상 클래스 추상 메서드 외에도, 일반 메서드, 필드, 생성자를 가질 수 있다.




그럼 왜 추상 클래스보다 인터페이스를 우선하라는 걸까?
# 인터페이스를 우선하는 이유
---
## 1. 기존 클래스에 쉽게 새로운 인터페이스를 구현 가능하다.
인터페이스의 경우, 추상 메서드만 정의하고, 클래스 선언에 `implement`만 명시하면 쉽게, 추가할 수 있다.

하지만 추상 클래스의 경우, 기존 클래스 위에, 새로운 추상 클래스를 넣기가 어렵다. 
예를 들어 두 클래스가 같은 추상 클래스를 상속하게 만들려면, 의미론적으로 두 클래스는 추상 클래스의 자식 클래스여야 한다.  즉 두 클래스가 서로 연관성이 있어야 하므로, 까다로울 수 밖에 없다.
## 2.믹스인 정의에 효과적이다.
믹스인은 프로그래머가 특정 코드를 다른 클래스에 삽입 할 수 있도록 하는 프로그래밍 개념이다. 즉 어떤 클래스에 추가적인 기능을 혼합한 것이다.

예를 들어, `Student`클래스에 `Comparable`인터페이스를 `implements`해준다고 생각해보자. 그럼 기존 `Student`클래스에 `student`객체끼리 순서를 정할 수 있는 "추가적인 기능"을 혼합한 것이다.
## 3. 인터페이스는 계층 구조가 없는 타입 프레임워크를 만들 수 있다.
타입을 계층적으로 정의하면 여러 개념을 구조적으로 잘 표현할 수 있지만,
현실 세계에서는 계층적이지 않은 관계도 많다.

예를 들어, 작곡가와 가수를 생각해보자. 어떤 사람은 작곡가 겸 가수일 수도 있는데, 둘에는 계층구조가 없다.
```java
public interface Singer {
    AudioClip sing(Song song);
}

public interface SongWriter{
    Song compose(int chartPosition);
}

interface SingerSongWriter extends Singer, SongWriter{
    AudioClip strum();
    void actSensitive();
}
```
따라서 이를 추상 클래스 대신에, `interface`로 표현하면, `Singer`와 `SongWriter`를 둘다 구현해도 문제가 되지 않는다.

만약 이를 추상 클래스로 만들려 한다면. `Singer`, `SongWriter`, `SingerSongWriter`등 가능한 조합을 각각 추상 클래스로 만든 지저분한 계층 구조가 만들어진다.(추상 클래스는 단일 상속만 가능하기에 `Singer`와 `SongWriter`클래스를 동시 상속할 수 없기에)
## 4. 추상골격 구현 클래스
java8부터 default메서드가 등장하면서, 중복되는 메서드 구현을 하는 수고를 덜어주었지만, 디폴트 메서드는 여러 단점이 존재한다.

**디폴트 메서드 단점**  
1. Object 메소드인 equals와 hashcode를 디폴트 메소드로 제공 안함.  
2. 인터페이스는 인스턴스 필드를 가질 수 없고 public이 아닌 정적 메소드를 가질 수 없음.  
3. 본인이 만든 인터페이스가 아니면 디폴트 메소드를 추가할 수 없음.

이러한 단점들을 **추상 골격 구현 클래스**를 사용하여, 인터페이스와 추상 클래스의 장점을 모두 가져갈 수 있다.

여기서 **추상 골격 구현 클래스**란 타입은 인터페이스로 정의하고, 메서드 구현이 필요한 부분은 추상 클래스를 이용하는 것이다.

## 4. 컴포지션과 함께 활용하면 굉장히 효율적이다.

