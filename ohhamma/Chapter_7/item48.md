# 스트림 병렬화는 주의해서 적용하라

```
💡 계산도 정확하고 성능이 좋아졌음이 확실해졌을 때에만 병렬화 버전 코드를 운영 코드에 반영하라
```

- 동시성 프로그래밍에서 신경써야 하는 것들
    - **안전성**(safety)
    - **응답 가능**(liveness)

## 파이프라인 병렬화로 성능 개선을 기대하면 안되는 경우

- 데이터 소스가 `Stream.iterate`인 경우
- 중간 연산으로 `limit`을 쓰는 경우

## 병렬화의 효과가 가장 좋은 경우

- 스트림의 소스가 _의 인스턴스일 때
    - `ArrayList`
    - `HashMap`
    - `HashSet`
    - `ConcurrentHashMap`
    - `배열`

### 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있다

- 다수의 스레드에 분배하기 좋음

### 원소들을 순차적으로 실행할 때의 참조 지역성이 좋다

- 메모리에 연속해서 저장되는 구조
    - 참조 지역성이 가장 뛰어난 자료구조 : 기본 타입의 배열

### 종단 연산에서 수행하는 작업량이 많지 않고 순차적인 연산이 아니다

- **축소**
    - 파이프라인에서 만들어진 모든 원소를 하나로 합치는 작업
    - Stream의 `reduce` 메서드 중 하나
    - 완선된 형태로 제공되는 메서드 중 하나 : `min`, `max`, `count`, `sum`
- 조건에 맞으면 **바로 반환**되는 메서드
    - `anyMatch`, `allMatch`, `noneMatch`

```
⚠️ 가변 축소를 수행하는 Stream의 collect 메서드 → 병렬화에 적합하지 x
```

## 병렬화의 이점을 제대로 누리고 싶다면?

- **spliterator** 메서드를 재정의하라
- 결과 스트림의 병렬화 **성능**을 강도 높게 테스트하라

## 스트림을 잘못 병렬화했을 때의 문제점

- 성능 ↓
- **안전 실패**
    - 결과가 잘못되거나 오동작할 수 있음
    - 함수 객체가 명세대로 동작하지 않을 때 발생 가능 (ex. `reduce`)

## 스트림 병렬화는 오직 성능 최적화 수단이다

- 변경 전후로 반드시 **성능**을 테스트해보자
    - 운영 시스템과 흡사한 환경에서 테스트하자
    - 파이프라인이 수행하는 작업이 병렬화에 드는 추가 비용을 상쇄하지 못하면 성능 향상 미미
- 조건이 잘 갖춰지면 `parallel` 메서드 호출만으로 프로세서 코어 수에 비례하는 성능 향상을 만끽할 수 있다
    - 머신러닝, 데이터 처리 분야에 유용
- `SplittableRandom` : 무작위 수들로 이뤄진 스트림 병렬화 시 사용
    - `ThreadLocalRandom` : 단일 스레드에서 사용
    - `Random` : 모든 연산 동기화 → 성능 최악