# equals를 재정의하려거든 hashCode도 재정의하라

```
💡 equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다
```

## hashCode 일반 규약

- `equals` 비교에 사용되는 정보가 변경되지 않았다면, 그 객체의 `hashCode` 메서드는 항상 일관된 값을 반환해야한다 (애플리케이샨 다시 실행시 달라져도 상관x)
- `equals`가 두객체를 같다고 판단했으면 두 객체의 `hashCode`는 똑같은 값을 반환해야한다
- `equals`가 두 객체를 다르다고 판단했더라도 두 객체의 `hashCode`가 다른 값을 반환할 필요는 없다 (다른 값을 반환해야 해시테이블 성능이 높아진다)

## 좋은 hashCode를 작성하는 요령

- int 변수 result를 선언한후 값 `c`(해시코드)로 초기화
- 해당 객체 나머지 핵심 필드 `f`에 각각 다음 작업 수행
    - 기본 타입 필드 → Type.hashCode(f), Type은 박싱 클래스
    - 참조 타입 필드이면서 equals 메서드가 재귀적으로 호출해 비교한다면 hashCode도 재귀적으로 호출 (계산 복잡해지면 표준형의 hashCode 호출, 필드값이 null이면 0 사용)
    - 필드가 배열이면 핵심 원소 각각을 별도 필드처럼 다룬다. 핵심 원소가 하나도 없으면 단순히 상수(0추천). 모든 원소가 핵심 원소면 Arrays.hashCode 사용
- 계산한 해시코드 c로 result 갱신
- result 반환

---

- 파생필드는 해시코드 계산에서 제외
- equals 비교에 사용되지 않은 필드는 반드시 제외
- 소수로 곱함 → 시프트 연산과 뺄셈으로 대체, 최적화
- 정적 메서드 hash → 성능 아쉽다
- 불변 클래스, 해시코드 계산 비용 크면 → 캐싱방식 고려, 지연 초기화(스레드안정성 고려)
- 성능을 높인답시고 해시코드를 계산할때 핵심코드를 생략해서는 안된다
- hashCode가 반환하는 값의 생성 규칙을 API 사용자에게 자세히 공표하지 말자