# equals는 일반 규약을 지켜 재정의하라

재정의하기 쉬워보이지만 곳곳에 함정이 도사림

### 재정의하지 않아야 더 좋은 경우

```
💡 꼭 필요한 경우가 아니면 equals를 재정의하지 말자 !
```

- 각 인스턴스가 본질적으로 **고유**한 경우 : 동작하는 개체 (Thread)
- 인스턴스의 논리적 동치성을 **검사할 일이 없는** 경우
- 상위 클래스에서 재정의한 equals가 **하위 클래스**에도 딱 들어맞는 경우 : 대부분의 Set 구현체
- 클래스가 private이거나 package-private이고 equals 메서드를 **호출할 일이 없는** 경우

### equals를 재정의해야 하는 경우

- 객체 식별성이 아니라 논리적 동치성을 확인해야하는데,
  상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 **않은** 경우
- **값 클래스**인 경우
- **Map**과 **Set**의 원소로 사용 가능한 경우
- 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하는 **인스턴스 통제 클래스**인 경우
    - 재정의하지않아도됨 (Enum)

### 일반 규약
- equals 메서드는 **동치관계**를 구현한다
  - `반사성`(reflexivity)
  - `대칭성`(symmetry)
  - `추이성`(transivity)
  - `일관성`(consistency)
  - `null아님` : x.equals(null)은 false, 모든 객체가 null과 같지 않아야 한다

---

- equals 규약을 어기면 그 객체를 사용하는 다른 객체들이 어떻게 반응하는지 알 수 없다
- 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다
    - 상속 대신 컴포지션을 사용하라

```
💡 리스코프 치환 원칙 : 어떤 타입에 있어 중요한 속성이라면 그 하위 타입에서도 똑같이 잘 작동해야 한다
```

- 추상 클래스의 하위 클래스에서라면 equals 규약을 지키면서도 값을 추가할 수 있다
    - 태그 달린 클래스보다는 클래스 계층 구조를 활용하라
- equals의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안된다
    - 항시 메모리에 존재하는 객체만을 사용한 결정적 계산만 수행해야 한다

### 단계별 equals 메서드 구현 방법

1. `==` 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다
2. `instanceof` 연산자로 입력이 올바른 타입인지 확인한다
3. 입력을 올바른 타입으로 `형변환`한다
4. 입력 객체와 자기 자신의 대응되는 핵심 `필드`들이 모두 일치하는지 하나씩 검사한다

---

- float, double 제외한 기본 타입 필드 → `==`로 비교
- 참조 타입 필드 → `equals` 메서드로 비교
- float, double → 정적 메서드 `compare`로 비교 (특수 부동소수점값)

---

- 어떤 필드를 **먼저 비교**하느냐 → equals의 성능 좌우
    - 다를 가능성이 더 크거나 비교하는 비용이 싼 필드 먼저 비교
    - 객체의 논리적 상태와 관련없는 필드는 비교x

### 마지막 주의사항

- equals를 재정의할때 **hashCode**도 반드시 재정의하자
- 너무 복잡하게 해결하려 들지 말자 : 별칭(alias) 비교x
- Object 외의 타입을 매개변수로 받는 equals 메서드는 선언하지 말자
    - `@Override` 애너테이션 사용하자

### equals 테스트

- 구글의 AutoValue 프레임워크
- 사람이 직접 작성하는 것보다 IDE에 맡기는 편이 낫다