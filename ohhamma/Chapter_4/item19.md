# 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

- item18 → 문서화해놓지 않은 ‘외부’ 클래스를 상속할 때의 위험 경고
    - 외부 : 프로그래머의 통제권 밖에 있어서 언제 어떻게 변경될지 모름

## 상속을 고려한 설계와 문서화

### 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다

- 재정의 가능 메서드에 대한 사실 (재정의 가능 : public, protected 메서드 중 final이 아닌 모든 메서드)
- 어떤 순서로 호출, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지
- Implementation Requirements : 메서드의 내부 동작 방식 설명
    - 메서드 주석에 `@implSpec` 태그

### 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다

- 어떤 메서드를 protected로 노출해야할지는 어떻게 결정할까?
    - 실제 하위 클래스를 만들어 시험해보자

### 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다

- 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다
    - private, final, static 메서드는 재정의가 불가능 → 생성자에서 안심하고 호출해도 된다

### clone과 readObject 메서드

- 생성자와 비슷한 효과 : 구현시 제약
- 둘다 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다

### 상속용으로 설계하지 않은 클래스는 상속을 금지하자

```
💡 클래스를 상속용으로 설계하려면 엄청난 노력이 들고 그 클래스에 안기는 제약도 상당하다.
```

- 상속을 금지하는 방법
    - 클래스를 final로 선언한다
    - 모든 생성자를 private이나 package-private으로 선언하고 public 정적 팩터리를 만들어준다
- 그럼에도 상속을 꼭 허용해야겠다면
    - 클래스 내부에서 재정의 가능 메서드를 사용하지 않게 만들고 이 사실을 문서로 남기자
- 클래스의 동작을 유지하면서 재정의 가능 메서드를 사용하는 코드를 제거할 수 있는 방법
    - 각각의 재정의 가능 메서드 본문 → private 도우미 메서드