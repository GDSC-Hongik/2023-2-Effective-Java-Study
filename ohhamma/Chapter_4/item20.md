# 추상 클래스보다는 인터페이스를 우선하라

## 추상 클래스 vs 인터페이스

```
💡 일반적으로 다중 구현용 타입으로는 인터페이스가 가장 적합하다
```

- 인터페이스는 다른 어떤 클래스를 상속했든 같은 타입으로 취급
    - **BUT** 추상 클래스의 구현 클래스는 반드시 하위 클래스가 되어야 함
    - 새로운 타입 정의하는 데 커다란 제약
- 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해넣을 수 있다
    - **BUT** 기존 클래스 위에 새로운 추상 클래스를 끼워넣기 어려움
- 인터페이스는 믹스인(mixin) 정의에 안성맞춤
    - 믹스인 : 클래스가 구현할 수 있는 타입, 타입의 주된 기능 + 선택적 기능 혼합
    - **BUT** 추상 클래스로는 믹스인을 정의할 수 없음

## 인터페이스의 장점

- 계층구조가 없는 타입 프레임워크를 만들 수 있음
    - 조합 폭발 현상 방지 : 속성이 n개 → 지원해야 하는 조합의 수 2^n
- 래퍼 클래스와 함께 사용 → 기능을 향상시키는 안전하고 강력한 수단

## 디폴트 메서드

- 인터페이스 메서드 중 구현 방법이 명백한 경우 제공
- `@implSpec` 자바독 태그를 붙여 문서화

### 제약

- Object의 메서드 → 디폴트 메서드로 제공해서는 x
    - equals, hashCode
- 인스턴스 필드 가질 수 x
- public이 아닌 정적 멤버 가질 수 x
- 만들지 않은 인터페이스에는 디폴트 메서드 추가 불가능

## 인터페이스와 추상 골격 구현

- `템플릿 메서드 패턴`
- 인터페이스와 추상 클래스의 장점을 모두 취하는 방법
- 인터페이스 : 타입 정의 및 디폴트 메서드 제공 (`Interface`)
- 골격 구현 클래스 : 나머지 메서드들 구현 (`AbstractInterface`)

## 골격 구현 클래스

```
💡 '가능한 한' 인터페이스의 디폴트 메서드로 제공하자 (구현상 제약으로 추상 클래스로 제공하기도 함)
```

### 이점

- 추상 클래스의 장점 적용 & 단점 보완
    - 구현을 도와줌
    - 타입 정의할 때의 제약에서 자유로움

### 구조상 확장이 어려운 경우

- 인터페이스 직접 구현 : 디폴트 메서드의 이점
- 골격 구현 클래스를 우회적으로 이용 : 시뮬레이트한 다중 상속

### 작성법

- 다른 메서드 구현에 사용되는 **기반 메서드** 선정
    - 골격 구현에서 추상 메서드가 될 예정
- 기반 메서드 사용하여 직접 구현 가능한 메서드 → **디폴트 메서드**로 제공
    - Object 메서드 → 모두 골격 구현 클래스에 구현
- 기반 메서드나 디폴트 메서드로 만들지 못한 메서드 → 골격 구현 클래스에 작성
    - 필요 시 public이 아닌 필드, 메서드 추가
- 동작 방식 문서화
    - 기본적으로 상속해서 사용하기 때문

## 단순 구현

- 골격 구현의 작은 변종
    - **BUT** 추상 클래스가 아님
- 동작하는 가장 단순한 구현
- 필요에 맞게 확장