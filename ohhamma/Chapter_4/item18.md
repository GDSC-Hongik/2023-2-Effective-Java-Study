# 상속보다는 컴포지션을 사용하라

- 다른 패키지의 구체 클래스를 상속하는 일은 위험하다

## 메서드 호출과 달리 상속을 캡슐화를 깨뜨린다

- 상위 클래스 구현에 따라 하위 클래스 동작에 이상이 생길 수 있다 : HashSet
- 문제 해결을 위해 클래스의 내부 구현 방식을 알고 있어야 함

### 문제의 원인

- 메서드 재정의
    - 새로운 메서드를 추가하면 괜찮지 않을까? NO

### 해결책

- 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 하자
    - `컴포지션` : 기존 클래스가 새로운 클래스의 구성요소로 사용됨
    - `전달`(forwarding) : 새 클래스의 인스턴스 메서드 → 기존 클래스의 메서드 호출하여 결과 반환

## 데코레이터 패턴

- `래퍼 클래스` : 다른 클래스 인스턴스를 감싸고 있는 클래스
    - 단점이 거의 없음 : 하위 클래스보다 견고하고 강력하다
    - 콜백 프레임워크와는 어울리지 않음 (SELF 문제)

```
💡 상속은 반드시 하위 클래스가 상위 클래스의 ‘진짜’ 하위 타입인 상황에서만 쓰여야 한다. (is-a 관계)
```

## 컴포지션 대신 상속을 사용했을 때의 단점

- 내부 구현을 불필요하게 노출
- 클라이언트가 노출된 내부에 직접 접근
    - 불변식 파괴 가능
- 컴포지션으로 결함을 숨기는 새로운 API 설계 가능, **BUT** 상속은 상위 클래스 API의 결함까지도 승계한다