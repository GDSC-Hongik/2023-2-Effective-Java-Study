# 로 타입을 사용하지 말라

```
💡 로 타입을 사용하면 런타임에 예외가 일어날 수 있으니 사용하면 안 된다.
```

## 제네릭 타입

- 제네릭 클래스, 제네릭 인터페이스
- 클래스와 인터페이스 선언에 타입 매개변수가 쓰이는 경우
    - ex) `List<E>`
- 일련의 매개변수화 타입 정의
    - ex) `List<String>`
- 그에 딸린 로 타입도 함께 정의

## 로 타입

- 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않은 때
    - ex) `List`
- 제네릭 도입 전 코드와의 **호환**을 위한 수단

### 위험성

```
⚠️ 로 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다.
```

- 실수로 다른 타입의 인스턴스를 넣어도 아무 오류 없이 컴파일되고 실행됨
    - 제네릭 활용 → 타입 안전성 확보

```java
private final Collection<Stamps> stamps = ...;
```

### List vs List<Object>

- `List` : 제네릭 타입에서 완전히 발을 뺌
- `List<Object>` : 모든 타입을 허용한다는 의사 전달
- List<String>
    - `List`의 하위 타입 **o** → 타입 안정성 소실
    - `List<Object>`의 하위 타입 **x**

### 비한정적 와일드카드 타입

- **어떤 타입**이라도 담을 수 있는 가장 범용적인 매개변수화 타입
- 제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않을 때 사용
- **안전하다** : `Collection<?>`에는 (null 외에는) 어떤 원소도 넣을 수 없음

```java
static int numElementsInCommon(Set<?> s1, Set<?> s2) { ... }
```

## 로 타입을 써야 하는 경우

### class 리터럴

- `List.class`, `String[].class`, `int.class` → OK
- `List<String>.class`, `List<?>.class` → **NO**

### instanceof 연산자

- 런타임에 제네릭 타입 정보가 지워짐
- 비한정적 와일드카드 타입 외 매개변수화 타입 → 적용 불가능
- 비한정적 와일드카드 타입과 동일하게 동작

```java
if (o instance of Set) {    // 로 타입
	Set<?> s = (Set<?>) o;    // 와일드카드 타입
	...
}
```