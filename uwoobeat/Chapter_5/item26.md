## 타입 소거(Type Erasure)

(예전에 작성한 아티클에서 가져온 내용입니다)

### 로우타입에 대한 주저리

타입 소거 기능을 이해하기 위해서는 이 개념이 왜 등장했는지에 대한 맥락을 이해할 필요가 있다. 제네릭은 멋진 기능이다. 정말로! 하지만 우리가 컴퓨터 기술 분야에서 기능을 추가하거나 새 릴리즈를 배포하거나 업데이트를 하거나 등등… 의 상황에서 가장 중요하게 고려해야 할 것은 **하위 호환성(backward compatibility)**이다. 이를 간단하게 말하자면 ‘새롭게 나온 제품이 이전에 나온 제품에서도 정상적으로 작동할 수 있는가?’ 이다. 유튜브가 ‘이제는 인터넷 익스플로러에서 유튜브 지원 안 할 거에요!’ 하면서 아주 오랜 기간동안 사용자들에게 해당 내용을 안내했던 것을 생각해보자. 

제네릭 기능을 추가하는 것 역시 자바 진영에게는 꽤 고민되는 일이었다. 아무튼, 제네릭은 추가되었다. 하지만 제네릭을 사용하지 않는 것들에도 붙일 이름이 필요했다. 지금에 와서는 컬렉션을 `Collection<String>` 과 같이 제네릭 방식으로 사용하지만, 예전에 제네릭이 없을 때는 `Collection` 과 같이 타입 파라미터(ex: 위 예시의 String)를 쓰지 않고 사용했다. 이를 로우타입(raw type)이라 한다.

### 와일드카드 vs Object (feat. 공변과 무공변)

하위 호환성을 위해서 자바는 이 구시대의 유물인 로우타입을 어떻게든 처리해야 했다. 즉 로우타입과 제네릭의 관계(세부적으로는 형변환이 있겠다)를 재정립할 필요가 있었던 것이다. 그래서 자바는 새로운 개념을 도입했는데, 이것이 ‘와일드카드’이다. 와일드카드는 ‘어떠한 타입이든 가능하다’ 라는 의미를 가진다. 흔히 물음표 기호(?)로 표현된다.

하지만 자바를 공부하다 보면 비슷한 개념을 마주친다. 바로 모든 클래스의 조상이라고 알려진 `Object` 클래스이다. 최고 조상 클래스니까 어떤 타입이든 들어갈 수 있는 거나 마찬가지 아닌건가? 그럼 `Collection<?>` 과 `Collection<Object>` 의 차이는 뭐지? 라는 질문이 생길 수 있다.

둘의 차이는 공변(Covariance)와 무공변(Invariance)에 대한 개념으로 이해될 수 있다. 공변과 무공변은 프로그래밍 언어론의 ‘**서브타이핑**’과 관련있는 개념으로, 이는 7장에서 배운 데이터 타입의 ‘**형 변환**’은 물론 우리가 현재 다루고 있는 10장 서브 프로그램의 ‘**제네릭 함수**’ 그리고 더 나아가 15장 객체지향 프로그래밍의 ‘**다형성**’과도 관련있는 아주 중요한 내용이다. 

공변과 무공변에 대해 설명하기 이전에 몇몇 사례를 통해 직관적으로 이해해보자. 만약 `Collection<Object>` 타입의 참조변수에 `Collection<Integer>` 객체를 할당할 수 있을까? 불가능하다. 하지만 `Object` 의 서브타입이 `Integer` 이기에 `Collection<Object>` 의 서브타입 역시 `Collection<Integer>` 이기를 기대하지만 그렇지 않다는 것이다. 따라서 제네릭은 무공변이다. 하지만 배열의 경우 다르다. `Object[]` 타입에 `Integer[]` 객체를 할당할 수 있다. 따라서 배열은 공변이다.

이렇듯 공변과 무공변은 기능 T에 대해 다음과 같이 정리할 수 있다.

- A의 서브타입이 B일 때, T(A)의 서브타입이 T(B)인 경우 T는 공변이라고 한다.
- A의 서브타입이 B일 때, T(A)의 서브타입이 T(B)가 아닌 경우 T는 무공변이라고 한다.

와일드카드는 어떨까? `Fruit` 를 상속하는 `Apple` 을 가정하자. 그렇다면 `Collection<? extends Fruit>` 타입의 참조변수에 `Collection<Apple>` 을 할당할 수 있을까? 이것은 가능하다. 이는 컬렉션 제네릭에도 다형성을 적용할 수 있게 만들어준다.

하지만 `Collection<?>` 타입의 참조변수에는 오직 `null` 만 들어갈 수 있다. 왜일까? 일단 이렇게 설명해보자. 만약 `Collection<?>` 타입에 대하여 일단 `Collection<String>` 객체를 할당했다고 가정하자. 그리고 이것의 참조변수 이름을 `unknownCollection` 이라 하자. 그리고 여기에 한 정수 객체를 원소로 추가하는 경우를 가정하자. 이를 코드로 표현하면 다음과 같다.

```java
Collection<?> unknownCollection = new Collection<String>();

// fill unknownCollection with String objects

unknownCollection.add(new Integer(10)); // unsafe approach
```

여기서 Integer 객체를 원소로 추가하려고 하면 안전하지 않다. 하지만 그게 `null` 을 사용하는 것과 무슨 상관이냐? 싶을 수도 있겠다. 이는 뒤에서 언급할 타입 소거에 대해서 알고 있어야 더 잘 이해할 수 있다. 지금은 일단 타입 안정성이 훼손된다는 문제가 존재한다… 정도만 인지하고 넘어가도록 하자.


> 실제로 Collection 클래스는 인터페이스이기 때문에 `new Collection()`처럼 인스턴스화될 수 없다는 점을 명심하자. 저 자리에 ArrayList 같은 구현 클래스를 넣으면 적절할 것이다. 본래 공식문서 예시를 단순화하는 과정에서 이런저런 맥락이 빠졌고, 그래서 저렇게 문법적으로는 오류가 있는 코드가 만들어졌다고 보면 된다.


### 로우타입과 타입 안정성(type-safety), 그리고 무점검 경고(unchecked warning)

그렇다면 로우타입의 경우는 어떨까? 우리는  `Collection<Integer>` 타입의 참조변수에 `Collection` , 즉 로우타입 객체를 할당하는 것은? 앞에서 말한대로 타입 안정성이 훼손되는 일이다. 왜냐면 어떤 타입의 컬렉션이 들어올지 어떻게 안단 말인가? 그러니 앞에서 `null` 만 허용했던 것처럼 로우타입 역시 에러를 발생시켜야 할 것이다.

하지만, 컴파일러는 타입 안정성을 위한 에러 대신 ‘**무점검 경고(unchecked warning)**’를 발생시킨다. 왜 에러라고 하지 않는 것일까? 이는 앞서 말했듯이 로우타입의 하위 호환성을 보장하기 위해서다. 만약 이것을 에러라고 한다면, 이전 버전에서 로우타입으로 작성한 코드들은 새로운 제네릭 기반 시스템에서 호환되지 않을 것이다. 

즉, 로우 타입은 와일드카드 타입과 아주 유사하지만, 와일드카드 타입처럼 **엄격하게 타입 체킹**을 수행하지 않는다. 이는 제네릭이 기존 레거시 코드와 **상호운용**(interoperating)될 수 있도록 하기 위한 의도적인 설계 결정이다.

따라서 로우 타입을 사용하면 컴파일러는 타입 체크를 수행할 수 없으므로, 타입 오류가 런타임에 발생할 수 있다. 앞에서 소개했던 제네릭의 장점인 ‘타입 안정성’을 십분 살릴 수 없을 수도 있는 것이다.

### 타입 소거(type erasure)

하지만 이는 무점검 경고는 그저 경고일 뿐이고 결국 컴파일 에러를 발생시키지 않으므로 언제든지 오류의 여지가 존재한다. 그리고 무점검 경고가 직접적으로 ‘로우타입의 하위 호환성을 보장한다’고 말하기는 어렵다. 엄밀하게 말하자면, ‘무점검 경고 상황에서 에러를 발생시키지 않는 것’이 호환성 보장을 위한 첫번째 단계라고 봐야한다. 즉, 실질적으로 하위 호환성을 보장하는 기능은 따로 있다. 이것이 타입 소거(type erasure)이다.

더 자세하게 알아보자. 앞에서 무점검 경고를 무시하고 컴파일한다면, 타입 안정성이 망가지는 것인가? 아무리 하위 호환성이 중요하다 하더라도 타입 안정성을 무너트리면서까지 지켜야 할 것은 아닐 테다. 따라서 무점검 경고를 무시하고 컴파일하더라도 타입 안정성을 지키기 위해 타입 소거가 필요한 것이다. **타입 소거는 간단하게 말하자면, 꺽쇠 괄호 안에 있는 제네릭 타입 정보를 없애는 것이다**. 가령 `List<String>` 같은 파라미터화 된 타입은 로우타입인 `List` 로 변경한다. 즉 타입 변수의 upper-bound로 대체한다. 그리고 결과 코드의 타입이 일치하지 않는 경우 적절히 형변환한다.

타입 소거가 이루어지는 경우, 컴파일 타임에 정적 타입 체크가 수행되지만 런타임에는 타입 정보가 소거되기에 이를 알 수 없다. 즉, 로우 타입이든 제네릭 타입이든 결국 런타임에 타입 정보가 존재하지 않는 것은 마찬가지이다. 따라서 `List<Integer> list = new List();` 과 같은 코드 역시 타입 정보가 소거되므로 `List list = new List();` 가 된다. 즉 타입 소거가 안됐더라면 위 코드에서는 에러가 발생했겠지만 타입 소거를 수행하여 아래 코드와 같이 변환되기에 로우타입과 제네릭이 호환될 수 있는 것이다.

결과적으로 타입 안정성과 무결성은 어떤 상황에서든 지켜진다. 

무점검 경고를 무시하고 실행하는 경우에도 말이다!