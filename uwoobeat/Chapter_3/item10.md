# Item 10. equals는 일반 규약을 지켜 재정의하라

equals는 "같다"의 개념에 대한 것이다. 책에서는 equals를 재정의하지 않아도 되는 경우에 대해서 다루고 있다. 사실 이 경우보다는 equals를 재정의해야 하는 상황에 대해서 다루는 것이 더 적절할 듯 싶다.

- 각 인스턴스가 본질적으로 고유한 경우. 값을 표현하는 것이 아닌 동작하는 개체를 표현 -> 이는 "상태"를 가지지 않는 클래스를 말한다. 즉 자신의 멤버를 가지지 않고 행위만 가지는 클래스를 말한다.

- 논리적 동치성을 검사할 일이 없는 경우 -> 이는 VO와 관련되어 있다. 논리적 동치성이란 물리적 동치성과 대비되는 개념이다. 물리적 동치성이란 이 대상이 물리적으로 위치하는 공간이 동일한지를 묻는 것이다. 가령 1000원짜리 돈 객체과 똑같은 1000원짜리 돈 객체가 서로 메모리 상에 구분된 객체로 존재한다면 이 둘은 물리적 동치라고 말하기는 어렵다. 대신 우리는 논리적으로 1000원짜리 돈과 다른 1000원짜리 돈이 논리적으로는 동일하다고 말할 수 있다. 이를 값 객체(VO)라고 말한다. VO의 경우 equals를 오버라이딩하여 비교해야 한다.

- 상위 클래스에서 재정의한 equals가 하위 클래스에서도 적용되는 경우 -> 이는 당연한 일이다. 사실 이 표현은 반대로 생각해서 상위 클래스를 상속하는 하위 클래스에서 equals가 동일하게, 최소한 유사하게 동작해야 한다는 점을 시사한다고 봐야 한다. 뒤에서 리스코프 치환 원칙 이야기가 나오는데 이 규칙은 상속 관계를 구현할 때 지켜야 하는 원칙에 대한 이야기이다. 

- 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없는 경우 -> private 클래스의 경우 외부에서 접근할 수 없으므로 equals를 오버라이딩할 필요가 없다. 가령 싱글톤의 경우 equals를 호출할 일이 없다. 

equals를 재정의할 때는 동치관계를 구현해야 하는데 이는 이산수학을 배운 분들이라면 이미 익숙한 내용이리라고 믿는다. 다만 코드 구현에 있어서는 생소할 수도 있다. 반사성과 대칭성, 추이성, 일관성을 지켜야 한다.

추가로 참고해야 할 점은 equals를 재정의할 때는 hashcode 역시 오버라이딩해야 하며, equals의 네 가지 규칙에 대한 단위 테스트 역시 작성해야 한다. 하지만 우리는 일반적으로 롬복이 올바르게 작동할 것이라는 믿음을 가지고 가므로 굳이 단위 테스트를 작성할 필요는 없다. 레코드도 마찬가지다.

한편 JPA 엔티티를 오버라이딩 할 때는 Hibernate.getClass() 를 사용해야 한다. 프록시 객체를 사용하기 때문이다.

https://velog.io/@nmrhtn7898/JPA-Entity%EC%97%90%EC%84%9C-equals-hashcode-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EB%B0%9C%EC%83%9D%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%AC%B8%EC%A0%9C%EC%A0%90