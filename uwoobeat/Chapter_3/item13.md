# Item 13. clone 재정의는 주의해서 진행하라

Clonable 인터페이스는 복제 가능함을 알려주는 인터페이스이다. 하지만 이런저런 문제점이 있다.

clone() 메서드가 선언된 곳이 Cloneable이 아닌 Object이고 protected이다. 즉 Cloneable 인터페이스는 어떤 메서드도 갖고 있지 않다.

그렇다면 어떻게 작동할까? 이 인터페이스를 구현한 클래스의 인스턴스는 clone 호출 시 필드가 복사된 객체를 반환한다. 하지만 이 인터페이스를 구현하지 않은 클래스의 인스턴스는 CloneNotSupportedException을 던진다. 즉 Cloneable 인터페이스는 복제 가능한지를 알려주는 용도로 사용된다.

clone 메서드는 생성자가 아닌 방식으로 객체를 생성할 수 있다는 점에서 상당히 위험하다. 우리가 지금까지 봐왔던 정적 팩토리 메서드, 빌더 등은 결국 끝단에서는 생성자를 호출하기 때문에 신뢰할 수 있다. 하지만 clone 메서드는 생성자를 호출하지 않고 객체를 생성하기 때문에, 생성자와 같은 효과를 보장할 수 없다. 가령 우리가 생성자 구현에 특정한 제약조건 (파라미터의 값이 양수여야 한다는 등) 을 걸어놓았다면, clone 메서드는 이 제약조건을 무시하고 객체를 생성할 수 있다.

이는 불변 객체와 가변 객체에 적용된다. 불변 객체를 복제하는 것은 간단하다.

```java
@Override
public PhoneNumber clone() {
    try {
        return (PhoneNumber) super.clone();
    } catch (CloneNotSupportedException e) {
        throw new AssertionError(); // 일어날 수 없는 일이다.
    }
}
```

Object 클래스의 clone() 메서드를 오버라이드한다 (Cloneable 인터페이스가 아님에 주의하라). 그리고 부모 클래스의 clone() 메서드를 호출한 후 PhoneNumber 타입으로 캐스팅한다. 이때 CloneNotSupportedException이 발생할 수 있으므로 try-catch 문으로 감싸준다.

하지만 가변 객체는 어떨까? 앞에서 논의했던 Stack 클래스 예제를 보자. 우리는 Object 배열과 size 변수를 가지고 있었다. 이때 clone() 메서드를 호출하면 어떻게 될까? 맞다. 복제된 인스턴스는 Object 배열과 동일한 배열을 가리키게 된다. 즉, "배열"을 복사하는 것이 아니라 "배열의 참조"를 복사하는 것이다. 따라서 이를 해결하려면 배열을 복사하는 코드를 추가하면 된다.

```java
@Override
public Stack clone() {
    try {
        Stack result = (Stack) super.clone();
        result.elements = elements.clone();
        return result;
    } catch (CloneNotSupportedException e) {
        throw new AssertionError();
    }
}
```

배열의 clone의 경우 모든 원소에 대하여 수행하므로 깊은 복사가 이루어진다. 하지만 이 방법의 경우 재할당이 발생하므로 좋지 않은 방식이다. "가변 객체를 참조하는 필드는 final로 선언하라"고 했다. 하지만 elements 멤버 변수를 final로 선언하게 되면 `result.elements = elements.clone()` 는 작동하지 않을 것이다. 즉 clone하기 위해서 final을 제거하게 되는 아쉬운 점이 발생하게 된다.

한편 배열의 값이 참조값을 갖는 경우를 생각해볼 수 있다. 해시 테이블은 버킷들의 배열이며, 이 배열은 다시 또 연결 리스트의 첫번째 엔트리를 참조한다. 그렇다면 이 버킷들의 배열을 deepcopy 한다 하더라도, 같은 연결 리스트를 참조하고 있으므로 문제가 발생할 수 있다. 이 경우에는 버킷이 가리키는 연결 리스트까지 복사해야 한다.

이런 식으로 내부 멤버 구성이 복잡한 객체인 경우에는 모든 일들을 clone() 메서드를 통해 해결하기 어렵다. 이 때는 clone() 을 통해 모든 필드를 초기 상태로 설정하고, 우리가 별도로 메서드를 작성하여 필요한 필드들을 복사하는 방식을 사용할 수 있다.

가령 앞의 해시 테이블 예시의 경우 버킷 배열을 새로 만든 다음에 `put(key, val)` 을 통하여 원본 엔트리를 하나씩 넣어주면 된다. 이 방식은 기존 방식보다 코드적으로는 깔끔하지만 clone이 제공하는 로우 레벨 기능을 이용하는 것보다는 성능이 아쉽다.


별개로 clone 메서드에서는 오버라이딩될 수 있는 메서드를 호출하지 말아야 한다. 서브클래스에서 재정의한 메서드를 호출하게 되면 복제 과정에서 원본과의 상태가 달라질 가능성이 크다. 위의 `pub(key, val)` 를 포함하는 메서드같은 경우에는 final이나 private로 선언하여 오버라이딩을 막아야 한다. 아니면, 애초부터 상속이 가능하다면 Cloneable 인터페이스를 구현하지 않는 것이 좋다.

마지막으로 thread-safe한 클래스를 작성하기 위해서는 동기화를 신경써줘야 한다. Object의 clone 메서드는 동기화를 전제하고 만들어지지 않았다. 


### 결론
- Cloneable 인터페이스를 구현한다면 clone을 재정의해야 한다.
- 이때 실무에서는 접근 제어자는 public으로, 리턴 타입은 자기 자신으로 하기 위해 캐스팅해준다.
- super.clone()을 호출한 후 필요한 필드들을 복사한다.
    - 가변 객체들은 적절히 복사해준다.
    - 원시 타입이나 불변 객체 참조의 경우 그대로 둔다.
    - 객체마다의 불변값은 고유값이므로 수정해줘야 한다.
- 굳이 clone을 사용하지 않아도 되는 경우에는 복제 생성자나 복사 팩토리 메서드를 사용한다.
    - `Stack copy = new Stack(stack);`
    - `Stack copy = Stack.newInstance(stack);`
    - 이 방식은 생성자를 우회하여 객체를 생성하는 기존 방식보다 안전하다.
    - 또한 이 방식은 자기 자신뿐만이 아니라 "인터페이스" 타입을 인자로 받을 수 있으므로 다양한 타입의 객체를 자신의 타입으로 복사할 수 있다.