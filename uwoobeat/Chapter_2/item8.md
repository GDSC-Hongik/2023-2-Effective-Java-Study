Item 8. finalizer와 cleaner 사용을 피하라

c++ 를 배웠다면 소멸자(destructor)에 대해서도 배웠을 것이다. 소멸자는 객체가 소멸될 때 호출되는 메서드이다. 주로 메모리를 해제하거나 파일을 닫는 등의 작업이 필요할 때 이를 사용했다. 자바도 비슷하다. 자바에서 객체의 소멸은 GC에 의해서 발생한다. 즉, GC가 객체를 수거할 때 호출된다.

어떻게 사용할까? `finalize()` 메서드를 오버라이드하여 사용한다. 왜 쓸까? 마찬가지로 Item 7에서 언급했듯이 메모리 누수 등을 방지하게 위해 쓴다고 할 수 있다. 하지만 finalizer는 몇 가지 문제점이 아니라 그냥 총체적 난국 수준으로 문제점이 많았기 때문에 Java 9부터 deprecated 되었다.

어떤 문제가 있냐?

먼저 제거되어야 하는 객체의 수명이 연장된다. `finalize()` 를 오버라이드되면 GC가 수집될 때 바로 회수되지 않고 대기 큐에 들어간다. 그리고, 그 큐를 돌면서 각 객체마다 정의된 `finalize()` 를 호출한다. `finalize()` 수행이 끝난 후에야 진짜 GC에 의해 수거된다. GC가 다시 찾아올 때까지 기다리면 되지 않냐? 싶을 수도 있다. 하지만 JVM Heap의 Old Generation 영역은 참조되지 않은 객체들이 많은 Young Generation과 다르게 참조되고 있는, 즉 살아있는 객체들이 많다. 이 살아있는 객체를 처리하는 것은 느리다. 따라서 GC 입장에서는 Old Generation에 대한 GC, 즉 Major GC를 드물게 발생시킬 수밖에 없다. GC의 주기가 길다는 것이다. 따라서 `finalize()` 가 존재하면 Major GC를 두 번이나 돌아야 하기 때문에 이는 상당히 긴 리소스 낭비로 이어질 수 있다.

https://jaeyeong951.medium.com/finalize-%EC%9D%80%ED%87%B4%EC%8B%9D-4a52fb855910
https://woooongs.tistory.com/51

예외처리가 불가능하다는 문제가 있다. 일반적으로 예외가 발생하면 이 예외는 무시되고 finalize는 그냥 중단되어 버린다. 스택 트레이스도 출력되지 않는다.

언제 수행될지도 알 수 없다. 왜냐면 GC 자체가 언제 수집을 시작할지 모르기 때문이다. 만약 해당 객체의 리소스 반납을 전제로 하는 로직이 존재한다면, 해당 로직은 언제 수행될지 모르기 때문에 문제를 발생시킬 수 있다. 더 나아가, 수행이 될지 / 안될지조차 예측할 수 없다. JLS는 finalize()가 반드시 실행될 것을 보장하지 않는다. 가령 데이터베이스의 락을 해제하는 로직이 finalize()에 있다면, 이 락은 해제되지 않을 수도 있다. 그 결과는 무엇일까? 데드락이다.

finalizer는 보안 상 문제가 존재한다. 어떻게? 악의적인 서브클래스에서 finalize()를 오버라이드하여 객체의 상태를 읽어들이거나 수정할 수 있다. 이는 객체 생성 시 보안 검사가 수행되는 경우에도 우회될 수 있다. 자세한 내용은 아래 링크를 참고하자.

https://yangbongsoo.tistory.com/8

파일 / 스레드 닫기 등에 권장되는 방법은 AutoClosable 인터페이스를 implements 하는 것이다. 그리고 이는 close() 메서드를 오버라이드하여 사용한다. 이는 try-with-resources 구문과 함께 사용하면 된다. 다음 아이템에서 상세히 다룰 것이다.

cleaner와 finalizer를 사용해야 하는 상황이 있을까? 먼저 자원 소유자가 이렇게 만들어진 close를 호출하지 않을 경우를 대비하여 일종의 안전망처럼 기능한다는 것이다. 솔직히 글쎄? 싶다. 옛날이었으면 몰라도 요즘 세상에는 워낙 신기한게 많아서 정적 코드 분석 도구 같은 것들을 쓰면 굳이 부작용이 더 많은 finalizer를 쓸 이유가 없을 것 같다. Builder 때처럼...

혹은 네이티브 피어와 연결된 객체이다. 네이티브 객체가 뭐냐? 자바에는 JNI라는 것이 있다. 자바는 플랫폼 독립성을 가진 언어로 알려져 있고 JVM이 자바가 토스한 플랫폼 종속성을 받아내는 역할을 한다. 플랫폼 독립성을 가졌다는 것은 특정 운영체제에서만 지원되는 기능은 쓰지 못한다는 것을 의미한다. 내가 윈도우에서만 지원하는 기능을 자바에서 만든다면 윈도우가 아닌 환경에서 JVM을 구동시키면 그 코드는 동작하지 않지 않겠나? 하지만 이런 기능이 필요할 수도 있다. 그래서 JNI라는 것이 존재한다.

```java
class HelloWorld
{
	private native void print();

	public static void main(String[] args)
	{
		new HelloWorld().print();
	}

	static{
		System.loadLibrary("HelloWorld");
	}
}

```

이런 기능을 수행하는 클래스의 인스턴스를 참조하고 있는 것을 네이티브 피어와 연결된 객체라고 한다. 이때 JNI로 구현된 코드에서 점유하고 있는 자원을 자원을 회수해야 하면 finalizer를 사용할 수 있긴 한데... 이 경우에도 그냥 close를 쓰는 게 낫다.



https://www.itworld.co.kr/news/224419
