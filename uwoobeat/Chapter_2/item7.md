# Item 7. 다 쓴 객체 참조를 해제하라

자바에는 GC가 존재한다. 따라서 C++처럼 직접 메모리를 해제해주지 않더라도, GC가 알아서 메모리를 해제해준다. 그렇다고 메모리를 아예 신경쓰지 않아도 되는 것은 아니다. 책의 스택 예제를 실행하는 프로그램의 경우 장기간 구동될 경우 OOM이나 디스크 페이징을 발생시킬 수 있다. 그 이유는 무엇일까? 이는 내부 `Object[]` 배열과 관련이 있다.

구현을 보자. 이 스택은 배열에 한 칸씩 인자를 넣어주는데, 스택이 꽉 찬 경우 배열의 크기를 두 배로 늘려준다. 그런데, 두 배로 늘린 후에 스택이 다 비어버리더라도 배열의 길이는 변하지 않는다. 그런데 이때 `pop()` 을 하면서 배열은 해당 객체의 참조를 리턴한 후 인덱스 포인터를 변경할 뿐 실제로 배열에서 객체를 퇴출시키지 않는다. 이때문에 `pop()` 이후에도 배열은 참조를 유지하고 있게 된다. 해당 참조를 쓸 일이 없는데도 말이다. 이걸 "다 쓴 참조(obsolete reference)" 라고 한다.

GC는 다 쓴 참조를 해제하지 않는다. 뿐만 아니라, 다 쓴 참조가 가지고 있는 다른 참조도 해제하지 않는다. 그래서 우리가 스택에 넣은 객체가 실제로는 아주 가벼울 지라도 그 객체가 아주아주 무거운 객체를 참조하고 있다면, 이 객체 역시 해제되지 않기 때문에 성능에 악영향을 줄 수 있다.

이를 해결하는 방법은 간단하다. 포인터만 바꿔주는 게 아니라, 바꿔주기 전에 배열이 참조하는 객체를 null로 만들어주면 된다. 이렇게 되면 참조 객체는 어떤 대상으로부터도 참조되지 않게 되고, GC가 해당 객체를 해제할 수 있게 된다.

이렇게 하면서 얻는 이점이 하나 더 있다. 바로 유효하지 않은 값을 참조하게 되는 일을 막을 수 있다. 가령 어떤 스택이 사이즈 100까지 늘어났다가 지금은 20만큼의 크기를 유지하고 있다고 하자. 일반적으로 어떤 배열에 대해서 크기가 20이라고 했을 때 21이라는 위치에 접근하면 예외가 발생해야 하는 것이 옳다. 하지만 위의 스택의 경우 내부 클래스에서 (`elements` 는 private 멤버이므로 내부에서 접근하는 것만 가능) 21이라는 인덱스로 접근하게 되더라도 어쨌든 참조가 가리키는 객체를 얻을 수 있으므로 다른 개발자가 이를 인지하지 못하고 유효하지 않은 값 (== 이미 pop 해버린 값) 을 참조하는 일을 막을 수 있다.

하지만 참조를 null로 초기화해주는 것이 마냥 좋은 것은 아니다. 로직이 더러워지고, 클린코드 관점에서도 그닥 좋지 못한 방법이다. 굉장히 예외적인 케이스라는 걸 알아야 한다. 즉 자신의 메모리를 직접 관리하는 클래스의 경우 메모리 누수에 조심해야 한다. Stack의 경우 elements 배열을 통해 메모리를 직접 관리하고 있으므로 유의해야 한다.

그 외에 메모리 누수를 발생시키는 대상으로 Map 자료구조를 사용하는 캐시가 있다. 캐시에 존재하는 엔트리는 GC의 대상이 되지 않는다. 캐시 엔트리를 참조할 때 지워주는 방법도 괜찮지만, `WeakHashMap` 을 사용할 수도 있다. 이 자료구조는 `WeakReference` 클래스의 원리를 이용한다. 그러면 이건 또 뭐냐? 쉽다. 기존에 참조변수로 어떤 객체를 new로 생성해서 할당해주었다면 이건 "강한 참조"라고 해서 GC에 의해 수거되지 않지만 "약한 참조" 객체는 GC가 돌면 null이 되어버리기 때문에 `WeakReference` 를 참조하는 참조변수는 null을 참조하는 것이 되어버린다.

이렇게 `WeakReference` 를 사용하여 `WeakHashMap` 의 키를 구현한다. 그러면 사용된 엔트리는 자동으로 제거되며, 사용되지 않는 엔트리는 자동으로 GC에 의해 수거된다.

https://blog.breakingthat.com/2018/08/26/java-collection-map-weakhashmap/