# Item 15. 클래스와 멤버의 접근 권한을 최소화하라

잘 설계된 컴포넌트는 자신의 내부 멤버과 구현을 잘 숨기고 있다. 이를 캡슐화라고 한다. 캡슐화는 객체지향의 핵심 특성 중 하나이다. 그렇다면 왜 '잘 숨겼는지'가 이리도 중요해지는가? 많은 사람들이 캡슐화의 필요성은 인지하고 있지만 그 이유에 대해서는 느낌적인 느낌 내지는 요상한 비유를 통해서 이를 받아들이게 된다. 이번 아이템에서는 캡슐화의 필요성을 구체적으로 설명하고, 이를 위해 어떻게 접근 권한을 최소화해야 하는지를 설명한다.

책에서는 캡슐화의 장점으로 다음을 언급하고 있다.

- 여러 컴포넌트를 병렬로 개발할 수 있어 개발 속도를 높인다.
    - 서로 상호작용하는 컴포넌트를 개발할 때 어느 한 쪽을 개발해야 다른 한 쪽을 개발할 수 있다면 개발 진척에 데드락이 걸리기 쉽다. 따라서 둘을 독립적으로 개발할 수 있는 것이 중요하다. 이때, 자신의 구현을 잘 숨겼다는 것은 구현이 완료되었든 완료되지 않았든 다른 컴포넌트 개발자가 외부에 제공된 인터페이스를 바탕으로 개발할 수 있다는 것을 의미한다.
    - 즉, '독립적인 컴포넌트'를 병렬로 개발하는 것은 캡슐화 여부와 관계없다. 하지만 '서로 의존적인 컴포넌트'를 병렬로 개발하기 위해서는 컴포넌트의 컨텍스트가 잘 분리되어 있어야 하며 이는 캡슐화를 통해 이루어진다.
- 시스템 관리 비용을 낮춘다.
    - 어떠한 컴포넌트의 구현이 감춰졌다는 것은 구현이 감춰지더라도 외부에 노출된 컨텍스트를 통해 원할히 사용될 수 있다는 것을 의미한다. 우리는 `userRepository.save(user)` 에서 save 메서드의 구현이 무엇인지는 모르겠지만 인터페이스 명세에 적혀진 혹은 메서드 이름이나 그것이 사용되는 코드를 통해 대충 이렇게 쓰는 게 아닐까?를 추측할 수 있다. 이 추측을 통해 우리는 컴포넌트 학습에 대한 비용을 낮출 수 있다.

두 장점을 설명할 때 공통적으로 언급된 부분이 바로 컨텍스트의 분리이다. 캡슐화를 '숨기는 것'으로 이해하기 보다는 '분리하는 것'으로 이해하면 좋다. 내부 구현을 '숨기려면' 내부 구현과 인터페이스를 '분리해야' 한다. 그러면 자연스럽게 인터페이스는 외부로 노출되고 외부와 내부가 구별되게 된다.

캡슐화는 어떻게 구현될까?

일단 모든 클래스와 멤버는 최대한 노출되지 않도록 한다. 즉 노출되어도 되고 노출되지 않아도 된다면 노출시키지 않는 쪽을 택하라는 것이다. 이때 톱레벨 클래스와 인터페이스의 경우 package-private와 public이 가능한데, 패키지 내부에서만 사용되는 것이라면 당연히 public으로 둘 필요가 없다. 이렇게 패키지 내에서 private인 클래스들은 인터페이스(API)가 아닌 구현이 되므로 언제든지 교체할 수 있다. (여기서 더 나아가 생각해본다면, 인터페이스의 경우 가능한 한 변경을 최소화하는 것이 좋고 변경이 발생할 수 있는 부분은 구현으로 빼는 것이 좋다는 것을 알 수 있다.)

멤버의 경우 private, package-private, protected, public이 가능하다. package-private의 경우 디폴트 접근 수준이기 때문에 default 접근 제어자를 사용한다. 접근 제어 수준은 접근 가능한 대상이 같은 클래스인지 / 같은 패키지인지 / 자손 클래스인지 / 전체 클래스인지에 따라 달라진다. 이때 private부터 public으로 접근 범위가 넓어지기 때문에 위의 캡슐화 규칙에 따라서 private부터 시작해서 한 단계씩 풀어나가는 식으로 구현해야 한다. 

한편 오버라이드의 경우 상위 클래스의 접근제어보다 더 좁게 설정될 수 없다. 이는 리스코프 치환 원칙과 관련되어 있다. 리스코프 치환 원칙의 경우 SOLID 중 가장 이해하기 어렵다고 볼 수 있는 원칙인데, 간단히 말하면 '아래로 갈수록 규칙이 더 빡세지면 안된다' 라는 거다. 리스코프 치환 원칙을 위배하는 경우 상속받은 자식 클래스를 상위 클래스로 업캐스팅하여 사용할 때 예상치 못한 문제가 발생할 수 있다. 

또한 public 클래스의 인스턴스 필드의 경우 public일 경우 외부에서 접근하여 재할당이 가능하므로 thread-safe 하지 않게 될 가능성이 발생한다. 따라서 private로 설정하게 해야 한다. 

배열의 경우 final로 선언되더라도 배열의 내부 원소는 변경될 수 있으므로 public으로 노출되면 안된다. 이때는 배열을 private으로 선언하고, public 메서드를 통해 배열의 복사본을 반환하도록 해야 한다. 혹은 불변 리스트를 반환하도록 해도 된다.