# Item 21. 인터페이스는 구현하는 쪽을 생각해 설계하라

인터페이스는 추상 클래스의 다중 상속을 해결할 수 있었지만 그럼에도 문제점이 하나 존재했었다. 바로 공통된 동작이 존재하지 않기 때문에 확장성이 아쉽다는 거였다. 만약 `Playable` 이라는 인터페이스에 대하여 `play()` 라는 추상 메서드만 존재하다가, 이후 버전에서 `stop()` 이라는 메서드가 추가되었다고 가정해보자. 이 경우 `Playable` 인터페이스를 구현한 모든 클래스들은 `stop()` 메서드를 구현해야 한다. 만약 `Playable` 인터페이스를 구현한 클래스가 100개라면, 100개의 클래스를 모두 수정해야 한다. 이런 문제를 해결하기 위해 자바 8에서는 디폴트 메서드를 지원하기 시작했다. 

하지만 디폴트 메서드 기능이 추가되면서 이런저런 문제점이 생기게 되었다. 먼저 자바 8 이전의 인터페이스 구현체는 디폴트 메서드라는 것을 전제하고 만들어지지 않았기 때문에, 자바 7 세상에 사는 구현체에게 갑작스레 추가된 디폴트 메서드가 딱 알맞게 호환될 것이라고 기대하기는 어렵다. 호환성을 맞춰주면 되는 것 아니냐? 라고 말할 수도 있겠지만 그것 역시 어렵다. 인터페이스는 구현체에 대해서 "전부 알 수는 없다". 자신을 구현한 구현체가 얼마나 존재할 것인가? 그리고 그 구현체에 대하여 문제 없이 디폴트 메서드를 만들려면 어떻게 해야 하는가? 구현체의 가능성은 언제나 열려있기 때문에 100퍼센트 대비하는 것이란 어렵다. 

그런데 짜짠! 자바 라이브러리는 그 어려운 걸 해냈습니다... 사실 완벽하게는 아니지만 나쁘지 않게 해냈다. 그럼에도 예외 케이스란 존재하는데 바로 책에서 언급하는 SynchronizedCollection이다. 딱 봐도 thread-safe 하게 생긴 놈이고 특수한 구현이 들어가 있을 거란 걸 알 수 있다. 그런데 Collection 인터페이스의 디폴트 메서드인 removeIf는 어떨까? 구현을 모르더라도 대충 예상해보자면 컬렉션을 돌면서 -> 조건에 맞으면 삭제하고 -> 계속 반복 이런 형태라는 걸 알 수 있다.

그런데 말이다, 이 removeIf가 과연 SynchronizedCollection를 염두에 두고 만들었을까? lock을 꽉 잡고 synchronized 키워드를 쓰는 방식으로? 아니다. Collection 인터페이스는 모든 구현체를 고려할 수 없다. 이러한 컨텍스트를 모르는 순수한 개발자가 SynchronizedCollection에서 아 이것도 thread-safe한 메서드겠거니 하면서 removeIf를 사용하게 되면 큰 낭패를 보게 될 것이다.

이걸 해결하려면? 쉽다. 디폴트 메서드를 오버라이드 쳐주면 된다. 그런데 이것도 조금 쓰읍,,, 스럽긴 하다. 왜냐? 인터페이스에서 메서드 하나 추가해주면 모든 구현체에서 다 구현쳐주는 게 싫어! 하면서 추상 클래스처럼 구현부가 있는 디폴트 메서드를 추가해준 건데, 이게 구현체마다 특성이 달라서 다르게 동작하는 문제가 있네? 그러면 문제 생긴 놈들은 알아서 오버라이딩 해라~ 하면서 짬때리는 것이 뭔가 모순적이라는 거다. 하지만 어쩌겠나? 세상은 불공평하고 디폴트 메서드로 인해서 이득을 보는 놈들이 많기 때문에 SynchronizedCollection 같이 마이너한 놈들은 피해를 보기 마련이다.

아무튼 이러한 사례에서 알 수 있는 것은, 디폴트 메서드는 "구현부"가 있는 메서드이기 때문에 당연히 그 인터페이스를 구현한 구현체에도 영향을 줄 거라는 사실을 염두에 두어야 한다는 것이다. 따라서 꼭 필요한 경우에만 추가하는 것으로 하고, 구현체에는 문제 없을까? 에 대해서도 고민을 해야 한다. 그래야 앞에서 설명했던 템플릿 메서드 패턴처럼 디폴트 메서드의 추가로 큰 이득을 챙겨갈 수 있다.